// THIS FILE IS GENERATED BY api-generator, DO NOT EDIT DIRECTLY!

// 初始化一个 Multipart Upload 任务之后，可以根据指定的对象名称和 UploadId 来分片上传数据
package resumable_upload_v2_upload_part

import (
	"encoding/json"
	io "github.com/qiniu/go-sdk/v7/internal/io"
	errors "github.com/qiniu/go-sdk/v7/storagev2/errors"
	uptoken "github.com/qiniu/go-sdk/v7/storagev2/uptoken"
)

// 调用 API 所用的请求
type Request struct {
	BucketName string            // 存储空间名称
	ObjectName *string           // 对象名称
	UploadId   string            // 在服务端申请的 Multipart Upload 任务 id
	PartNumber int64             // 每一个上传的分片都有一个标识它的号码
	Md5        string            // 上传块内容的 md5 值，如果指定服务端会进行校验，不指定不校验
	UpToken    uptoken.Provider  // 上传凭证，如果为空，则使用 HTTPClientOptions 中的 UpToken
	Body       io.ReadSeekCloser // 请求体
}

// 获取 API 所用的响应
type Response struct {
	Etag string // 上传块内容的 etag，用来标识块，completeMultipartUpload API 调用的时候作为参数进行文件合成
	Md5  string // 上传块内容的 MD5 值
}

// 返回本次上传的分片相关信息
type NewPartInfo = Response
type jsonResponse struct {
	Etag string `json:"etag"` // 上传块内容的 etag，用来标识块，completeMultipartUpload API 调用的时候作为参数进行文件合成
	Md5  string `json:"md5"`  // 上传块内容的 MD5 值
}

func (j *Response) MarshalJSON() ([]byte, error) {
	if err := j.validate(); err != nil {
		return nil, err
	}
	return json.Marshal(&jsonResponse{Etag: j.Etag, Md5: j.Md5})
}
func (j *Response) UnmarshalJSON(data []byte) error {
	var nj jsonResponse
	if err := json.Unmarshal(data, &nj); err != nil {
		return err
	}
	j.Etag = nj.Etag
	j.Md5 = nj.Md5
	return nil
}
func (j *Response) validate() error {
	if j.Etag == "" {
		return errors.MissingRequiredFieldError{Name: "Etag"}
	}
	if j.Md5 == "" {
		return errors.MissingRequiredFieldError{Name: "Md5"}
	}
	return nil
}
