// THIS FILE IS GENERATED BY api-generator, DO NOT EDIT DIRECTLY!

// 仅获取对象的元信息，不返回对象的内容
package stat_object

import (
	"context"
	"encoding/base64"
	"encoding/json"
	auth "github.com/qiniu/go-sdk/v7/auth"
	credentials "github.com/qiniu/go-sdk/v7/storagev2/credentials"
	httpclient "github.com/qiniu/go-sdk/v7/storagev2/http_client"
	region "github.com/qiniu/go-sdk/v7/storagev2/region"
	"net/url"
	"strconv"
	"strings"
)

type RequestPath struct {
	fieldEntry string
}

func (pp *RequestPath) GetEntry() string {
	return pp.fieldEntry
}
func (pp *RequestPath) SetEntry(value string) *RequestPath {
	pp.fieldEntry = value
	return pp
}
func (pp *RequestPath) getBucketName() (string, error) {
	return strings.SplitN(pp.fieldEntry, ":", 2)[0], nil
}
func (path *RequestPath) build() []string {
	var allSegments []string
	if path.fieldEntry != "" {
		allSegments = append(allSegments, base64.URLEncoding.EncodeToString([]byte(path.fieldEntry)))
	}
	return allSegments
}

// 调用 API 所用的 URL 查询参数
type RequestQuery struct {
	fieldNeedParts bool // 如果文件是通过分片上传的，是否返回对应的分片信息
}

func (query *RequestQuery) GetNeedParts() bool {
	return query.fieldNeedParts
}
func (query *RequestQuery) SetNeedParts(value bool) *RequestQuery {
	query.fieldNeedParts = value
	return query
}
func (query *RequestQuery) build() url.Values {
	allQuery := make(url.Values)
	if query.fieldNeedParts {
		allQuery.Set("needparts", strconv.FormatBool(query.fieldNeedParts))
	}
	return allQuery
}

// 每个分片的大小
type PartSizes = []int64

// 每个分片的大小，如没有指定 need_parts 参数则不返回
type Parts = PartSizes
type innerObjectMetadata struct {
	Size                    int64     `json:"fsize,omitempty"`               // 对象大小，单位为字节
	Hash                    string    `json:"hash,omitempty"`                // 对象哈希值
	MimeType                string    `json:"mimeType,omitempty"`            // 对象 MIME 类型
	Type                    int64     `json:"type,omitempty"`                // 对象存储类型，`0` 表示普通存储，`1` 表示低频存储，`2` 表示归档存储
	PutTime                 int64     `json:"putTime,omitempty"`             // 文件上传时间，UNIX 时间戳格式，单位为 100 纳秒
	UnfreezingStatus        int64     `json:"restoreStatus,omitempty"`       // 归档存储文件的解冻状态，`2` 表示解冻完成，`1` 表示解冻中；归档文件冻结时，不返回该字段
	Status                  int64     `json:"status,omitempty"`              // 文件状态。`1` 表示禁用；只有禁用状态的文件才会返回该字段
	Md5                     string    `json:"md5,omitempty"`                 // 对象 MD5 值，只有通过直传文件和追加文件 API 上传的文件，服务端确保有该字段返回
	ExpirationTime          int64     `json:"expiration,omitempty"`          // 文件过期删除日期，UNIX 时间戳格式，文件在设置过期时间后才会返回该字段
	TransitionToIaTime      int64     `json:"transitionToIA,omitempty"`      // 文件生命周期中转为低频存储的日期，UNIX 时间戳格式，文件在设置转低频后才会返回该字段
	TransitionToArchiveTime int64     `json:"transitionToARCHIVE,omitempty"` // 文件生命周期中转为归档存储的日期，UNIX 时间戳格式，文件在设置转归档后才会返回该字段
	Parts                   PartSizes `json:"parts,omitempty"`               // 每个分片的大小，如没有指定 need_parts 参数则不返回
}

// 文件元信息
type ObjectMetadata struct {
	inner innerObjectMetadata
}

func (j *ObjectMetadata) GetSize() int64 {
	return j.inner.Size
}
func (j *ObjectMetadata) SetSize(value int64) *ObjectMetadata {
	j.inner.Size = value
	return j
}
func (j *ObjectMetadata) GetHash() string {
	return j.inner.Hash
}
func (j *ObjectMetadata) SetHash(value string) *ObjectMetadata {
	j.inner.Hash = value
	return j
}
func (j *ObjectMetadata) GetMimeType() string {
	return j.inner.MimeType
}
func (j *ObjectMetadata) SetMimeType(value string) *ObjectMetadata {
	j.inner.MimeType = value
	return j
}
func (j *ObjectMetadata) GetType() int64 {
	return j.inner.Type
}
func (j *ObjectMetadata) SetType(value int64) *ObjectMetadata {
	j.inner.Type = value
	return j
}
func (j *ObjectMetadata) GetPutTime() int64 {
	return j.inner.PutTime
}
func (j *ObjectMetadata) SetPutTime(value int64) *ObjectMetadata {
	j.inner.PutTime = value
	return j
}
func (j *ObjectMetadata) GetUnfreezingStatus() int64 {
	return j.inner.UnfreezingStatus
}
func (j *ObjectMetadata) SetUnfreezingStatus(value int64) *ObjectMetadata {
	j.inner.UnfreezingStatus = value
	return j
}
func (j *ObjectMetadata) GetStatus() int64 {
	return j.inner.Status
}
func (j *ObjectMetadata) SetStatus(value int64) *ObjectMetadata {
	j.inner.Status = value
	return j
}
func (j *ObjectMetadata) GetMd5() string {
	return j.inner.Md5
}
func (j *ObjectMetadata) SetMd5(value string) *ObjectMetadata {
	j.inner.Md5 = value
	return j
}
func (j *ObjectMetadata) GetExpirationTime() int64 {
	return j.inner.ExpirationTime
}
func (j *ObjectMetadata) SetExpirationTime(value int64) *ObjectMetadata {
	j.inner.ExpirationTime = value
	return j
}
func (j *ObjectMetadata) GetTransitionToIaTime() int64 {
	return j.inner.TransitionToIaTime
}
func (j *ObjectMetadata) SetTransitionToIaTime(value int64) *ObjectMetadata {
	j.inner.TransitionToIaTime = value
	return j
}
func (j *ObjectMetadata) GetTransitionToArchiveTime() int64 {
	return j.inner.TransitionToArchiveTime
}
func (j *ObjectMetadata) SetTransitionToArchiveTime(value int64) *ObjectMetadata {
	j.inner.TransitionToArchiveTime = value
	return j
}
func (j *ObjectMetadata) GetParts() PartSizes {
	return j.inner.Parts
}
func (j *ObjectMetadata) SetParts(value PartSizes) *ObjectMetadata {
	j.inner.Parts = value
	return j
}
func (j *ObjectMetadata) MarshalJSON() ([]byte, error) {
	return json.Marshal(&j.inner)
}
func (j *ObjectMetadata) UnmarshalJSON(data []byte) error {
	return json.Unmarshal(data, &j.inner)
}

// 获取 API 所用的响应体参数
type ResponseBody = ObjectMetadata

// 调用 API 所用的请求
type Request struct {
	BucketHosts region.EndpointsProvider
	Path        RequestPath
	Query       RequestQuery
	Credentials credentials.CredentialsProvider
}

func (request Request) getBucketName(ctx context.Context) (string, error) {
	if bucketName, err := request.Path.getBucketName(); err != nil || bucketName != "" {
		return bucketName, err
	}
	return "", nil
}
func (request Request) getAccessKey(ctx context.Context) (string, error) {
	if request.Credentials != nil {
		if credentials, err := request.Credentials.Get(ctx); err != nil {
			return "", err
		} else {
			return credentials.AccessKey, nil
		}
	}
	return "", nil
}

// 获取 API 所用的响应
type Response struct {
	Body ResponseBody
}

// API 调用客户端
type Client struct {
	client *httpclient.HttpClient
}

// 创建 API 调用客户端
func NewClient(options *httpclient.HttpClientOptions) *Client {
	client := httpclient.NewHttpClient(options)
	return &Client{client: client}
}
func (client *Client) Send(ctx context.Context, request *Request) (*Response, error) {
	serviceNames := []region.ServiceName{region.ServiceRs}
	var pathSegments []string
	pathSegments = append(pathSegments, "stat")
	pathSegments = append(pathSegments, request.Path.build()...)
	path := "/" + strings.Join(pathSegments, "/")
	req := httpclient.Request{Method: "GET", ServiceNames: serviceNames, Path: path, RawQuery: request.Query.build().Encode(), AuthType: auth.TokenQiniu, Credentials: request.Credentials}
	var queryer *region.BucketRegionsQueryer
	if client.client.GetRegions() == nil && client.client.GetEndpoints() == nil {
		queryer = client.client.GetBucketQueryer()
		if queryer == nil {
			bucketHosts := httpclient.DefaultBucketHosts()
			var err error
			if request.BucketHosts != nil {
				if bucketHosts, err = request.BucketHosts.GetEndpoints(ctx); err != nil {
					return nil, err
				}
			}
			if queryer, err = region.NewBucketRegionsQueryer(bucketHosts, nil); err != nil {
				return nil, err
			}
		}
	}
	if queryer != nil {
		bucketName, err := request.getBucketName(ctx)
		if err != nil {
			return nil, err
		}
		accessKey, err := request.getAccessKey(ctx)
		if err != nil {
			return nil, err
		}
		req.Region = queryer.Query(accessKey, bucketName)
	}
	var respBody ResponseBody
	if _, err := client.client.AcceptJson(ctx, &req, &respBody); err != nil {
		return nil, err
	}
	return &Response{Body: respBody}, nil
}
