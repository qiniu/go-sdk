// THIS FILE IS GENERATED BY api-generator, DO NOT EDIT DIRECTLY!

// 在将所有数据分片都上传完成后，必须调用 completeMultipartUpload API 来完成整个文件的 Multipart Upload。用户需要提供有效数据的分片列表（包括 PartNumber 和调用 uploadPart API 服务端返回的 Etag）。服务端收到用户提交的分片列表后，会逐一验证每个数据分片的有效性。当所有的数据分片验证通过后，会把这些数据分片组合成一个完整的对象
package resumable_upload_v2_complete_multipart_upload

import (
	"encoding/json"
	errors "github.com/qiniu/go-sdk/v7/storagev2/errors"
	uptoken "github.com/qiniu/go-sdk/v7/storagev2/uptoken"
)

// 调用 API 所用的请求
type Request struct {
	BucketName   string            // 存储空间名称
	ObjectName   *string           // 对象名称
	UploadId     string            // 在服务端申请的 Multipart Upload 任务 id
	UpToken      uptoken.Provider  // 上传凭证，如果为空，则使用 HTTPClientOptions 中的 UpToken
	Parts        Parts             // 已经上传的分片列表
	FileName     string            // 上传的原始文件名，若未指定，则魔法变量中无法使用 fname，ext，suffix
	MimeType     string            // 若指定了则设置上传文件的 MIME 类型，若未指定，则根据文件内容自动检测 MIME 类型
	Metadata     map[string]string // 用户自定义文件 metadata 信息的键值对，可以设置多个，MetaKey 和 MetaValue 都是 string，，其中 可以由字母、数字、下划线、减号组成，且长度小于等于 50，单个文件 MetaKey 和 MetaValue 总和大小不能超过 1024 字节，MetaKey 必须以 `x-qn-meta-` 作为前缀
	CustomVars   map[string]string // 用户自定义变量
	ResponseBody interface{}       // 响应体，如果为空，则 Response.Body 的类型由 encoding/json 库决定
}

// 单个分片信息
type PartInfo struct {
	PartNumber int64  // 每一个上传的分片都有一个标识它的号码
	Etag       string // 上传块的 etag
}
type jsonPartInfo struct {
	PartNumber int64  `json:"partNumber"` // 每一个上传的分片都有一个标识它的号码
	Etag       string `json:"etag"`       // 上传块的 etag
}

func (j *PartInfo) MarshalJSON() ([]byte, error) {
	if err := j.validate(); err != nil {
		return nil, err
	}
	return json.Marshal(&jsonPartInfo{PartNumber: j.PartNumber, Etag: j.Etag})
}
func (j *PartInfo) UnmarshalJSON(data []byte) error {
	var nj jsonPartInfo
	if err := json.Unmarshal(data, &nj); err != nil {
		return err
	}
	j.PartNumber = nj.PartNumber
	j.Etag = nj.Etag
	return nil
}
func (j *PartInfo) validate() error {
	if j.PartNumber == 0 {
		return errors.MissingRequiredFieldError{Name: "PartNumber"}
	}
	if j.Etag == "" {
		return errors.MissingRequiredFieldError{Name: "Etag"}
	}
	return nil
}

// 分片信息列表
type Parts = []PartInfo

// 新上传的对象的相关信息
type ObjectInfo = Request
type jsonRequest struct {
	Parts      Parts             `json:"parts"`                // 已经上传的分片列表
	FileName   string            `json:"fname,omitempty"`      // 上传的原始文件名，若未指定，则魔法变量中无法使用 fname，ext，suffix
	MimeType   string            `json:"mimeType,omitempty"`   // 若指定了则设置上传文件的 MIME 类型，若未指定，则根据文件内容自动检测 MIME 类型
	Metadata   map[string]string `json:"metadata,omitempty"`   // 用户自定义文件 metadata 信息的键值对，可以设置多个，MetaKey 和 MetaValue 都是 string，，其中 可以由字母、数字、下划线、减号组成，且长度小于等于 50，单个文件 MetaKey 和 MetaValue 总和大小不能超过 1024 字节，MetaKey 必须以 `x-qn-meta-` 作为前缀
	CustomVars map[string]string `json:"customVars,omitempty"` // 用户自定义变量
}

func (j *Request) MarshalJSON() ([]byte, error) {
	if err := j.validate(); err != nil {
		return nil, err
	}
	return json.Marshal(&jsonRequest{Parts: j.Parts, FileName: j.FileName, MimeType: j.MimeType, Metadata: j.Metadata, CustomVars: j.CustomVars})
}
func (j *Request) UnmarshalJSON(data []byte) error {
	var nj jsonRequest
	if err := json.Unmarshal(data, &nj); err != nil {
		return err
	}
	j.Parts = nj.Parts
	j.FileName = nj.FileName
	j.MimeType = nj.MimeType
	j.Metadata = nj.Metadata
	j.CustomVars = nj.CustomVars
	return nil
}
func (j *Request) validate() error {
	if len(j.Parts) == 0 {
		return errors.MissingRequiredFieldError{Name: "Parts"}
	}
	for _, value := range j.Parts {
		if err := value.validate(); err != nil {
			return err
		}
	}
	return nil
}

// 获取 API 所用的响应
type Response struct {
	Body interface{}
}

func (j *Response) MarshalJSON() ([]byte, error) {
	return json.Marshal(j.Body)
}
func (j *Response) UnmarshalJSON(data []byte) error {
	return json.Unmarshal(data, &j.Body)
}
