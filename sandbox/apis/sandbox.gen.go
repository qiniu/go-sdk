// Package apis provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package apis

import (
	"bytes"
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"

	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
	AccessTokenAuthScopes = "AccessTokenAuth.Scopes"
	ApiKeyAuthScopes      = "ApiKeyAuth.Scopes"
)

// Defines values for AWSRegistryType.
const (
	Aws AWSRegistryType = "aws"
)

// Defines values for GCPRegistryType.
const (
	Gcp GCPRegistryType = "gcp"
)

// Defines values for GeneralRegistryType.
const (
	Registry GeneralRegistryType = "registry"
)

// Defines values for LogLevel.
const (
	LogLevelDebug LogLevel = "debug"
	LogLevelError LogLevel = "error"
	LogLevelInfo  LogLevel = "info"
	LogLevelWarn  LogLevel = "warn"
)

// Defines values for LogsDirection.
const (
	LogsDirectionBackward LogsDirection = "backward"
	LogsDirectionForward  LogsDirection = "forward"
)

// Defines values for LogsSource.
const (
	LogsSourcePersistent LogsSource = "persistent"
	LogsSourceTemporary  LogsSource = "temporary"
)

// Defines values for SandboxState.
const (
	Paused  SandboxState = "paused"
	Running SandboxState = "running"
)

// Defines values for TemplateBuildStatus.
const (
	TemplateBuildStatusBuilding TemplateBuildStatus = "building"
	TemplateBuildStatusError    TemplateBuildStatus = "error"
	TemplateBuildStatusReady    TemplateBuildStatus = "ready"
	TemplateBuildStatusWaiting  TemplateBuildStatus = "waiting"
)

// AWSRegistry defines model for AWSRegistry.
type AWSRegistry struct {
	// AwsAccessKeyID AWS Access Key ID for ECR authentication
	AwsAccessKeyID string `json:"awsAccessKeyId"`

	// AwsRegion AWS Region where the ECR registry is located
	AwsRegion string `json:"awsRegion"`

	// AwsSecretAccessKey AWS Secret Access Key for ECR authentication
	AwsSecretAccessKey string `json:"awsSecretAccessKey"`

	// Type Type of registry authentication
	Type AWSRegistryType `json:"type"`
}

// AWSRegistryType Type of registry authentication
type AWSRegistryType string

// AssignTemplateTagsRequest defines model for AssignTemplateTagsRequest.
type AssignTemplateTagsRequest struct {
	// Tags Tags to assign to the template
	Tags []string `json:"tags"`

	// Target Target template in "name:tag" format
	Target string `json:"target"`
}

// AssignedTemplateTags defines model for AssignedTemplateTags.
type AssignedTemplateTags struct {
	// BuildID Identifier of the build associated with these tags
	BuildID openapi_types.UUID `json:"buildID"`

	// Tags Assigned tags of the template
	Tags []string `json:"tags"`
}

// BuildLogEntry defines model for BuildLogEntry.
type BuildLogEntry struct {
	// Level State of the sandbox
	Level LogLevel `json:"level"`

	// Message Log message content
	Message string `json:"message"`

	// Step Step in the build process related to the log entry
	Step *string `json:"step,omitempty"`

	// Timestamp Timestamp of the log entry
	Timestamp time.Time `json:"timestamp"`
}

// BuildStatusReason defines model for BuildStatusReason.
type BuildStatusReason struct {
	// LogEntries Log entries related to the status reason
	LogEntries *[]BuildLogEntry `json:"logEntries,omitempty"`

	// Message Message with the status reason, currently reporting only for error status
	Message string `json:"message"`

	// Step Step that failed
	Step *string `json:"step,omitempty"`
}

// CPUCount CPU cores for the sandbox
type CPUCount = int32

// ConnectSandbox defines model for ConnectSandbox.
type ConnectSandbox struct {
	// Timeout Timeout in seconds from the current time after which the sandbox should expire
	Timeout int32 `json:"timeout"`
}

// DeleteTemplateTagsRequest defines model for DeleteTemplateTagsRequest.
type DeleteTemplateTagsRequest struct {
	// Name Name of the template
	Name string `json:"name"`

	// Tags Tags to delete
	Tags []string `json:"tags"`
}

// DiskSizeMB Disk size for the sandbox in MiB
type DiskSizeMB = int32

// EnvVars defines model for EnvVars.
type EnvVars map[string]string

// EnvdVersion Version of the envd running in the sandbox
type EnvdVersion = string

// Error defines model for Error.
type Error struct {
	// Code Error code
	Code int32 `json:"code"`

	// Message Error
	Message string `json:"message"`
}

// FromImageRegistry defines model for FromImageRegistry.
type FromImageRegistry struct {
	union json.RawMessage
}

// GCPRegistry defines model for GCPRegistry.
type GCPRegistry struct {
	// ServiceAccountJSON Service Account JSON for GCP authentication
	ServiceAccountJSON string `json:"serviceAccountJson"`

	// Type Type of registry authentication
	Type GCPRegistryType `json:"type"`
}

// GCPRegistryType Type of registry authentication
type GCPRegistryType string

// GeneralRegistry defines model for GeneralRegistry.
type GeneralRegistry struct {
	// Password Password to use for the registry
	Password string `json:"password"`

	// Type Type of registry authentication
	Type GeneralRegistryType `json:"type"`

	// Username Username to use for the registry
	Username string `json:"username"`
}

// GeneralRegistryType Type of registry authentication
type GeneralRegistryType string

// ListedSandbox defines model for ListedSandbox.
type ListedSandbox struct {
	// Alias Alias of the template
	Alias *string `json:"alias,omitempty"`

	// ClientID Identifier of the client
	// Deprecated:
	ClientID string `json:"clientID"`

	// CPUCount CPU cores for the sandbox
	CPUCount CPUCount `json:"cpuCount"`

	// DiskSizeMB Disk size for the sandbox in MiB
	DiskSizeMB DiskSizeMB `json:"diskSizeMB"`

	// EndAt Time when the sandbox will expire
	EndAt time.Time `json:"endAt"`

	// EnvdVersion Version of the envd running in the sandbox
	EnvdVersion EnvdVersion `json:"envdVersion"`

	// MemoryMB Memory for the sandbox in MiB
	MemoryMB MemoryMB         `json:"memoryMB"`
	Metadata *SandboxMetadata `json:"metadata,omitempty"`

	// SandboxID Identifier of the sandbox
	SandboxID string `json:"sandboxID"`

	// StartedAt Time when the sandbox was started
	StartedAt time.Time `json:"startedAt"`

	// State State of the sandbox
	State SandboxState `json:"state"`

	// TemplateID Identifier of the template from which is the sandbox created
	TemplateID string `json:"templateID"`
}

// LogLevel State of the sandbox
type LogLevel string

// LogsDirection Direction of the logs that should be returned
type LogsDirection string

// LogsSource Source of the logs that should be returned
type LogsSource string

// Mcp MCP configuration for the sandbox
type Mcp map[string]interface{}

// MemoryMB Memory for the sandbox in MiB
type MemoryMB = int32

// NewSandbox defines model for NewSandbox.
type NewSandbox struct {
	// AllowInternetAccess Allow sandbox to access the internet. When set to false, it behaves the same as specifying denyOut to 0.0.0.0/0 in the network config.
	AllowInternetAccess *bool `json:"allow_internet_access,omitempty"`

	// AutoPause Automatically pauses the sandbox after the timeout
	AutoPause *bool    `json:"autoPause,omitempty"`
	EnvVars   *EnvVars `json:"envVars,omitempty"`

	// Mcp MCP configuration for the sandbox
	Mcp      *Mcp                  `json:"mcp"`
	Metadata *SandboxMetadata      `json:"metadata,omitempty"`
	Network  *SandboxNetworkConfig `json:"network,omitempty"`

	// Secure Secure all system communication with sandbox
	Secure *bool `json:"secure,omitempty"`

	// TemplateID Identifier of the required template
	TemplateID string `json:"templateID"`

	// Timeout Time to live for the sandbox in seconds.
	Timeout *int32 `json:"timeout,omitempty"`
}

// ResumedSandbox defines model for ResumedSandbox.
type ResumedSandbox struct {
	// AutoPause Automatically pauses the sandbox after the timeout
	// Deprecated:
	AutoPause *bool `json:"autoPause,omitempty"`

	// Timeout Time to live for the sandbox in seconds.
	Timeout *int32 `json:"timeout,omitempty"`
}

// Sandbox defines model for Sandbox.
type Sandbox struct {
	// Alias Alias of the template
	Alias *string `json:"alias,omitempty"`

	// ClientID Identifier of the client
	// Deprecated:
	ClientID string `json:"clientID"`

	// Domain Base domain where the sandbox traffic is accessible
	Domain *string `json:"domain"`

	// EnvdAccessToken Access token used for envd communication
	EnvdAccessToken *string `json:"envdAccessToken,omitempty"`

	// EnvdVersion Version of the envd running in the sandbox
	EnvdVersion EnvdVersion `json:"envdVersion"`

	// SandboxID Identifier of the sandbox
	SandboxID string `json:"sandboxID"`

	// TemplateID Identifier of the template from which is the sandbox created
	TemplateID string `json:"templateID"`

	// TrafficAccessToken Token required for accessing sandbox via proxy.
	TrafficAccessToken *string `json:"trafficAccessToken"`
}

// SandboxDetail defines model for SandboxDetail.
type SandboxDetail struct {
	// Alias Alias of the template
	Alias *string `json:"alias,omitempty"`

	// ClientID Identifier of the client
	// Deprecated:
	ClientID string `json:"clientID"`

	// CPUCount CPU cores for the sandbox
	CPUCount CPUCount `json:"cpuCount"`

	// DiskSizeMB Disk size for the sandbox in MiB
	DiskSizeMB DiskSizeMB `json:"diskSizeMB"`

	// Domain Base domain where the sandbox traffic is accessible
	Domain *string `json:"domain"`

	// EndAt Time when the sandbox will expire
	EndAt time.Time `json:"endAt"`

	// EnvdAccessToken Access token used for envd communication
	EnvdAccessToken *string `json:"envdAccessToken,omitempty"`

	// EnvdVersion Version of the envd running in the sandbox
	EnvdVersion EnvdVersion `json:"envdVersion"`

	// MemoryMB Memory for the sandbox in MiB
	MemoryMB MemoryMB         `json:"memoryMB"`
	Metadata *SandboxMetadata `json:"metadata,omitempty"`

	// SandboxID Identifier of the sandbox
	SandboxID string `json:"sandboxID"`

	// StartedAt Time when the sandbox was started
	StartedAt time.Time `json:"startedAt"`

	// State State of the sandbox
	State SandboxState `json:"state"`

	// TemplateID Identifier of the template from which is the sandbox created
	TemplateID string `json:"templateID"`
}

// SandboxLog Log entry with timestamp and line
type SandboxLog struct {
	// Line Log line content
	Line string `json:"line"`

	// Timestamp Timestamp of the log entry
	Timestamp time.Time `json:"timestamp"`
}

// SandboxLogEntry defines model for SandboxLogEntry.
type SandboxLogEntry struct {
	Fields map[string]string `json:"fields"`

	// Level State of the sandbox
	Level LogLevel `json:"level"`

	// Message Log message content
	Message string `json:"message"`

	// Timestamp Timestamp of the log entry
	Timestamp time.Time `json:"timestamp"`
}

// SandboxLogs defines model for SandboxLogs.
type SandboxLogs struct {
	// LogEntries Structured logs of the sandbox
	LogEntries []SandboxLogEntry `json:"logEntries"`

	// Logs Logs of the sandbox
	Logs []SandboxLog `json:"logs"`
}

// SandboxMetadata defines model for SandboxMetadata.
type SandboxMetadata map[string]string

// SandboxMetric Metric entry with timestamp and line
type SandboxMetric struct {
	// CPUCount Number of CPU cores
	CPUCount int32 `json:"cpuCount"`

	// CPUUsedPct CPU usage percentage
	CPUUsedPct float32 `json:"cpuUsedPct"`

	// DiskTotal Total disk space in bytes
	DiskTotal int64 `json:"diskTotal"`

	// DiskUsed Disk used in bytes
	DiskUsed int64 `json:"diskUsed"`

	// MemTotal Total memory in bytes
	MemTotal int64 `json:"memTotal"`

	// MemUsed Memory used in bytes
	MemUsed int64 `json:"memUsed"`

	// Timestamp Timestamp of the metric entry
	// Deprecated:
	Timestamp time.Time `json:"timestamp"`

	// TimestampUnix Timestamp of the metric entry in Unix time (seconds since epoch)
	TimestampUnix int64 `json:"timestampUnix"`
}

// SandboxNetworkConfig defines model for SandboxNetworkConfig.
type SandboxNetworkConfig struct {
	// AllowOut List of allowed CIDR blocks or IP addresses for egress traffic. Allowed addresses always take precedence over blocked addresses.
	AllowOut *[]string `json:"allowOut,omitempty"`

	// AllowPublicTraffic Specify if the sandbox URLs should be accessible only with authentication.
	AllowPublicTraffic *bool `json:"allowPublicTraffic,omitempty"`

	// DenyOut List of denied CIDR blocks or IP addresses for egress traffic
	DenyOut *[]string `json:"denyOut,omitempty"`

	// MaskRequestHost Specify host mask which will be used for all sandbox requests
	MaskRequestHost *string `json:"maskRequestHost,omitempty"`
}

// SandboxState State of the sandbox
type SandboxState string

// SandboxesWithMetrics defines model for SandboxesWithMetrics.
type SandboxesWithMetrics struct {
	Sandboxes map[string]SandboxMetric `json:"sandboxes"`
}

// TeamUser defines model for TeamUser.
type TeamUser struct {
	// Email Email of the user
	Email string `json:"email"`

	// ID Identifier of the user
	ID openapi_types.UUID `json:"id"`
}

// Template defines model for Template.
type Template struct {
	// Aliases Aliases of the template
	Aliases []string `json:"aliases"`

	// BuildCount Number of times the template was built
	BuildCount int32 `json:"buildCount"`

	// BuildID Identifier of the last successful build for given template
	BuildID string `json:"buildID"`

	// BuildStatus Status of the template build
	BuildStatus TemplateBuildStatus `json:"buildStatus"`

	// CPUCount CPU cores for the sandbox
	CPUCount CPUCount `json:"cpuCount"`

	// CreatedAt Time when the template was created
	CreatedAt time.Time `json:"createdAt"`
	CreatedBy *TeamUser `json:"createdBy"`

	// DiskSizeMB Disk size for the sandbox in MiB
	DiskSizeMB DiskSizeMB `json:"diskSizeMB"`

	// EnvdVersion Version of the envd running in the sandbox
	EnvdVersion EnvdVersion `json:"envdVersion"`

	// LastSpawnedAt Time when the template was last used
	LastSpawnedAt *time.Time `json:"lastSpawnedAt"`

	// MemoryMB Memory for the sandbox in MiB
	MemoryMB MemoryMB `json:"memoryMB"`

	// Public Whether the template is public or only accessible by the team
	Public bool `json:"public"`

	// SpawnCount Number of times the template was used
	SpawnCount int64 `json:"spawnCount"`

	// TemplateID Identifier of the template
	TemplateID string `json:"templateID"`

	// UpdatedAt Time when the template was last updated
	UpdatedAt time.Time `json:"updatedAt"`
}

// TemplateAliasResponse defines model for TemplateAliasResponse.
type TemplateAliasResponse struct {
	// Public Whether the template is public or only accessible by the team
	Public bool `json:"public"`

	// TemplateID Identifier of the template
	TemplateID string `json:"templateID"`
}

// TemplateBuild defines model for TemplateBuild.
type TemplateBuild struct {
	// BuildID Identifier of the build
	BuildID openapi_types.UUID `json:"buildID"`

	// CPUCount CPU cores for the sandbox
	CPUCount CPUCount `json:"cpuCount"`

	// CreatedAt Time when the build was created
	CreatedAt time.Time `json:"createdAt"`

	// DiskSizeMB Disk size for the sandbox in MiB
	DiskSizeMB *DiskSizeMB `json:"diskSizeMB,omitempty"`

	// EnvdVersion Version of the envd running in the sandbox
	EnvdVersion *EnvdVersion `json:"envdVersion,omitempty"`

	// FinishedAt Time when the build was finished
	FinishedAt *time.Time `json:"finishedAt,omitempty"`

	// MemoryMB Memory for the sandbox in MiB
	MemoryMB MemoryMB `json:"memoryMB"`

	// Status Status of the template build
	Status TemplateBuildStatus `json:"status"`

	// UpdatedAt Time when the build was last updated
	UpdatedAt time.Time `json:"updatedAt"`
}

// TemplateBuildFileUpload defines model for TemplateBuildFileUpload.
type TemplateBuildFileUpload struct {
	// Present Whether the file is already present in the cache
	Present bool `json:"present"`

	// URL Url where the file should be uploaded to
	URL *string `json:"url,omitempty"`
}

// TemplateBuildInfo defines model for TemplateBuildInfo.
type TemplateBuildInfo struct {
	// BuildID Identifier of the build
	BuildID string `json:"buildID"`

	// LogEntries Build logs structured
	LogEntries []BuildLogEntry `json:"logEntries"`

	// Logs Build logs
	Logs   []string           `json:"logs"`
	Reason *BuildStatusReason `json:"reason,omitempty"`

	// Status Status of the template build
	Status TemplateBuildStatus `json:"status"`

	// TemplateID Identifier of the template
	TemplateID string `json:"templateID"`
}

// TemplateBuildLogsResponse defines model for TemplateBuildLogsResponse.
type TemplateBuildLogsResponse struct {
	// Logs Build logs structured
	Logs []BuildLogEntry `json:"logs"`
}

// TemplateBuildRequest defines model for TemplateBuildRequest.
type TemplateBuildRequest struct {
	// Alias Alias of the template
	Alias *string `json:"alias,omitempty"`

	// CPUCount CPU cores for the sandbox
	CPUCount *CPUCount `json:"cpuCount,omitempty"`

	// Dockerfile Dockerfile for the template
	Dockerfile string `json:"dockerfile"`

	// MemoryMB Memory for the sandbox in MiB
	MemoryMB *MemoryMB `json:"memoryMB,omitempty"`

	// ReadyCmd Ready check command to execute in the template after the build
	ReadyCmd *string `json:"readyCmd,omitempty"`

	// StartCmd Start command to execute in the template after the build
	StartCmd *string `json:"startCmd,omitempty"`

	// TeamID Identifier of the team
	TeamID *string `json:"teamID,omitempty"`
}

// TemplateBuildRequestV2 defines model for TemplateBuildRequestV2.
type TemplateBuildRequestV2 struct {
	// Alias Alias of the template
	Alias string `json:"alias"`

	// CPUCount CPU cores for the sandbox
	CPUCount *CPUCount `json:"cpuCount,omitempty"`

	// MemoryMB Memory for the sandbox in MiB
	MemoryMB *MemoryMB `json:"memoryMB,omitempty"`

	// TeamID Identifier of the team
	// Deprecated:
	TeamID *string `json:"teamID,omitempty"`
}

// TemplateBuildRequestV3 defines model for TemplateBuildRequestV3.
type TemplateBuildRequestV3 struct {
	// Alias Alias of the template. Deprecated, use name instead.
	// Deprecated:
	Alias *string `json:"alias,omitempty"`

	// CPUCount CPU cores for the sandbox
	CPUCount *CPUCount `json:"cpuCount,omitempty"`

	// MemoryMB Memory for the sandbox in MiB
	MemoryMB *MemoryMB `json:"memoryMB,omitempty"`

	// Name Name of the template. Can include a tag with colon separator (e.g. "my-template" or "my-template:v1"). If tag is included, it will be treated as if the tag was provided in the tags array.
	Name *string `json:"name,omitempty"`

	// Tags Tags to assign to the template build
	Tags *[]string `json:"tags,omitempty"`

	// TeamID Identifier of the team
	// Deprecated:
	TeamID *string `json:"teamID,omitempty"`
}

// TemplateBuildStartV2 defines model for TemplateBuildStartV2.
type TemplateBuildStartV2 struct {
	// Force Whether the whole build should be forced to run regardless of the cache
	Force *bool `json:"force,omitempty"`

	// FromImage Image to use as a base for the template build
	FromImage         *string            `json:"fromImage,omitempty"`
	FromImageRegistry *FromImageRegistry `json:"fromImageRegistry,omitempty"`

	// FromTemplate Template to use as a base for the template build
	FromTemplate *string `json:"fromTemplate,omitempty"`

	// ReadyCmd Ready check command to execute in the template after the build
	ReadyCmd *string `json:"readyCmd,omitempty"`

	// StartCmd Start command to execute in the template after the build
	StartCmd *string `json:"startCmd,omitempty"`

	// Steps List of steps to execute in the template build
	Steps *[]TemplateStep `json:"steps,omitempty"`
}

// TemplateBuildStatus Status of the template build
type TemplateBuildStatus string

// TemplateLegacy defines model for TemplateLegacy.
type TemplateLegacy struct {
	// Aliases Aliases of the template
	Aliases []string `json:"aliases"`

	// BuildCount Number of times the template was built
	BuildCount int32 `json:"buildCount"`

	// BuildID Identifier of the last successful build for given template
	BuildID string `json:"buildID"`

	// CPUCount CPU cores for the sandbox
	CPUCount CPUCount `json:"cpuCount"`

	// CreatedAt Time when the template was created
	CreatedAt time.Time `json:"createdAt"`
	CreatedBy *TeamUser `json:"createdBy"`

	// DiskSizeMB Disk size for the sandbox in MiB
	DiskSizeMB DiskSizeMB `json:"diskSizeMB"`

	// EnvdVersion Version of the envd running in the sandbox
	EnvdVersion EnvdVersion `json:"envdVersion"`

	// LastSpawnedAt Time when the template was last used
	LastSpawnedAt *time.Time `json:"lastSpawnedAt"`

	// MemoryMB Memory for the sandbox in MiB
	MemoryMB MemoryMB `json:"memoryMB"`

	// Public Whether the template is public or only accessible by the team
	Public bool `json:"public"`

	// SpawnCount Number of times the template was used
	SpawnCount int64 `json:"spawnCount"`

	// TemplateID Identifier of the template
	TemplateID string `json:"templateID"`

	// UpdatedAt Time when the template was last updated
	UpdatedAt time.Time `json:"updatedAt"`
}

// TemplateRequestResponseV3 defines model for TemplateRequestResponseV3.
type TemplateRequestResponseV3 struct {
	// Aliases Aliases of the template
	// Deprecated:
	Aliases []string `json:"aliases"`

	// BuildID Identifier of the last successful build for given template
	BuildID string `json:"buildID"`

	// Names Names of the template
	Names []string `json:"names"`

	// Public Whether the template is public or only accessible by the team
	Public bool `json:"public"`

	// Tags Tags assigned to the template build
	Tags []string `json:"tags"`

	// TemplateID Identifier of the template
	TemplateID string `json:"templateID"`
}

// TemplateStep Step in the template build process
type TemplateStep struct {
	// Args Arguments for the step
	Args *[]string `json:"args,omitempty"`

	// FilesHash Hash of the files used in the step
	FilesHash *string `json:"filesHash,omitempty"`

	// Force Whether the step should be forced to run regardless of the cache
	Force *bool `json:"force,omitempty"`

	// Type Type of the step
	Type string `json:"type"`
}

// TemplateUpdateRequest defines model for TemplateUpdateRequest.
type TemplateUpdateRequest struct {
	// Public Whether the template is public or only accessible by the team
	Public *bool `json:"public,omitempty"`
}

// TemplateWithBuilds defines model for TemplateWithBuilds.
type TemplateWithBuilds struct {
	// Aliases Aliases of the template
	Aliases []string `json:"aliases"`

	// Builds List of builds for the template
	Builds []TemplateBuild `json:"builds"`

	// CreatedAt Time when the template was created
	CreatedAt time.Time `json:"createdAt"`

	// LastSpawnedAt Time when the template was last used
	LastSpawnedAt *time.Time `json:"lastSpawnedAt"`

	// Public Whether the template is public or only accessible by the team
	Public bool `json:"public"`

	// SpawnCount Number of times the template was used
	SpawnCount int64 `json:"spawnCount"`

	// TemplateID Identifier of the template
	TemplateID string `json:"templateID"`

	// UpdatedAt Time when the template was last updated
	UpdatedAt time.Time `json:"updatedAt"`
}

// BuildID defines model for buildID.
type BuildID = string

// PaginationLimit defines model for paginationLimit.
type PaginationLimit = int32

// PaginationNextToken defines model for paginationNextToken.
type PaginationNextToken = string

// SandboxID defines model for sandboxID.
type SandboxID = string

// TemplateID defines model for templateID.
type TemplateID = string

// N400 defines model for 400.
type N400 = Error

// N401 defines model for 401.
type N401 = Error

// N403 defines model for 403.
type N403 = Error

// N404 defines model for 404.
type N404 = Error

// N409 defines model for 409.
type N409 = Error

// N500 defines model for 500.
type N500 = Error

// ListSandboxesParams defines parameters for ListSandboxes.
type ListSandboxesParams struct {
	// Metadata Metadata query used to filter the sandboxes (e.g. "user=abc&app=prod"). Each key and values must be URL encoded.
	Metadata *string `form:"metadata,omitempty" json:"metadata,omitempty"`
}

// GetSandboxesMetricsParams defines parameters for GetSandboxesMetrics.
type GetSandboxesMetricsParams struct {
	// SandboxIds Comma-separated list of sandbox IDs to get metrics for
	SandboxIds []string `form:"sandbox_ids" json:"sandbox_ids"`
}

// GetSandboxLogsParams defines parameters for GetSandboxLogs.
type GetSandboxLogsParams struct {
	// Start Starting timestamp of the logs that should be returned in milliseconds
	Start *int64 `form:"start,omitempty" json:"start,omitempty"`

	// Limit Maximum number of logs that should be returned
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`
}

// GetSandboxMetricsParams defines parameters for GetSandboxMetrics.
type GetSandboxMetricsParams struct {
	// Start Unix timestamp for the start of the interval, in seconds, for which the metrics
	Start *int64 `form:"start,omitempty" json:"start,omitempty"`
	End   *int64 `form:"end,omitempty" json:"end,omitempty"`
}

// RefreshSandboxJSONBody defines parameters for RefreshSandbox.
type RefreshSandboxJSONBody struct {
	// Duration Duration for which the sandbox should be kept alive in seconds
	Duration *int `json:"duration,omitempty"`
}

// UpdateSandboxTimeoutJSONBody defines parameters for UpdateSandboxTimeout.
type UpdateSandboxTimeoutJSONBody struct {
	// Timeout Timeout in seconds from the current time after which the sandbox should expire
	Timeout int32 `json:"timeout"`
}

// ListTemplatesParams defines parameters for ListTemplates.
type ListTemplatesParams struct {
	TeamID *string `form:"teamID,omitempty" json:"teamID,omitempty"`
}

// GetTemplateParams defines parameters for GetTemplate.
type GetTemplateParams struct {
	// NextToken Cursor to start the list from
	NextToken *PaginationNextToken `form:"nextToken,omitempty" json:"nextToken,omitempty"`

	// Limit Maximum number of items to return per page
	Limit *PaginationLimit `form:"limit,omitempty" json:"limit,omitempty"`
}

// GetTemplateBuildLogsParams defines parameters for GetTemplateBuildLogs.
type GetTemplateBuildLogsParams struct {
	// Cursor Starting timestamp of the logs that should be returned in milliseconds
	Cursor *int64 `form:"cursor,omitempty" json:"cursor,omitempty"`

	// Limit Maximum number of logs that should be returned
	Limit     *int32         `form:"limit,omitempty" json:"limit,omitempty"`
	Direction *LogsDirection `form:"direction,omitempty" json:"direction,omitempty"`
	Level     *LogLevel      `form:"level,omitempty" json:"level,omitempty"`

	// Source Source of the logs that should be returned from
	Source *LogsSource `form:"source,omitempty" json:"source,omitempty"`
}

// GetTemplateBuildStatusParams defines parameters for GetTemplateBuildStatus.
type GetTemplateBuildStatusParams struct {
	// LogsOffset Index of the starting build log that should be returned with the template
	LogsOffset *int32 `form:"logsOffset,omitempty" json:"logsOffset,omitempty"`

	// Limit Maximum number of logs that should be returned
	Limit *int32    `form:"limit,omitempty" json:"limit,omitempty"`
	Level *LogLevel `form:"level,omitempty" json:"level,omitempty"`
}

// ListSandboxesV2Params defines parameters for ListSandboxesV2.
type ListSandboxesV2Params struct {
	// Metadata Metadata query used to filter the sandboxes (e.g. "user=abc&app=prod"). Each key and values must be URL encoded.
	Metadata *string `form:"metadata,omitempty" json:"metadata,omitempty"`

	// State Filter sandboxes by one or more states
	State *[]SandboxState `form:"state,omitempty" json:"state,omitempty"`

	// NextToken Cursor to start the list from
	NextToken *PaginationNextToken `form:"nextToken,omitempty" json:"nextToken,omitempty"`

	// Limit Maximum number of items to return per page
	Limit *PaginationLimit `form:"limit,omitempty" json:"limit,omitempty"`
}

// CreateSandboxJSONRequestBody defines body for CreateSandbox for application/json ContentType.
type CreateSandboxJSONRequestBody = NewSandbox

// ConnectSandboxJSONRequestBody defines body for ConnectSandbox for application/json ContentType.
type ConnectSandboxJSONRequestBody = ConnectSandbox

// RefreshSandboxJSONRequestBody defines body for RefreshSandbox for application/json ContentType.
type RefreshSandboxJSONRequestBody RefreshSandboxJSONBody

// ResumeSandboxJSONRequestBody defines body for ResumeSandbox for application/json ContentType.
type ResumeSandboxJSONRequestBody = ResumedSandbox

// UpdateSandboxTimeoutJSONRequestBody defines body for UpdateSandboxTimeout for application/json ContentType.
type UpdateSandboxTimeoutJSONRequestBody UpdateSandboxTimeoutJSONBody

// CreateTemplateJSONRequestBody defines body for CreateTemplate for application/json ContentType.
type CreateTemplateJSONRequestBody = TemplateBuildRequest

// DeleteTemplateTagsJSONRequestBody defines body for DeleteTemplateTags for application/json ContentType.
type DeleteTemplateTagsJSONRequestBody = DeleteTemplateTagsRequest

// ManageTemplateTagsJSONRequestBody defines body for ManageTemplateTags for application/json ContentType.
type ManageTemplateTagsJSONRequestBody = AssignTemplateTagsRequest

// UpdateTemplateJSONRequestBody defines body for UpdateTemplate for application/json ContentType.
type UpdateTemplateJSONRequestBody = TemplateUpdateRequest

// RebuildTemplateJSONRequestBody defines body for RebuildTemplate for application/json ContentType.
type RebuildTemplateJSONRequestBody = TemplateBuildRequest

// CreateTemplateV2JSONRequestBody defines body for CreateTemplateV2 for application/json ContentType.
type CreateTemplateV2JSONRequestBody = TemplateBuildRequestV2

// StartTemplateBuildV2JSONRequestBody defines body for StartTemplateBuildV2 for application/json ContentType.
type StartTemplateBuildV2JSONRequestBody = TemplateBuildStartV2

// CreateTemplateV3JSONRequestBody defines body for CreateTemplateV3 for application/json ContentType.
type CreateTemplateV3JSONRequestBody = TemplateBuildRequestV3

// AsAWSRegistry returns the union data inside the FromImageRegistry as a AWSRegistry
func (t FromImageRegistry) AsAWSRegistry() (AWSRegistry, error) {
	var body AWSRegistry
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAWSRegistry overwrites any union data inside the FromImageRegistry as the provided AWSRegistry
func (t *FromImageRegistry) FromAWSRegistry(v AWSRegistry) error {
	v.Type = "aws"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAWSRegistry performs a merge with any union data inside the FromImageRegistry, using the provided AWSRegistry
func (t *FromImageRegistry) MergeAWSRegistry(v AWSRegistry) error {
	v.Type = "aws"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsGCPRegistry returns the union data inside the FromImageRegistry as a GCPRegistry
func (t FromImageRegistry) AsGCPRegistry() (GCPRegistry, error) {
	var body GCPRegistry
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromGCPRegistry overwrites any union data inside the FromImageRegistry as the provided GCPRegistry
func (t *FromImageRegistry) FromGCPRegistry(v GCPRegistry) error {
	v.Type = "gcp"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeGCPRegistry performs a merge with any union data inside the FromImageRegistry, using the provided GCPRegistry
func (t *FromImageRegistry) MergeGCPRegistry(v GCPRegistry) error {
	v.Type = "gcp"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsGeneralRegistry returns the union data inside the FromImageRegistry as a GeneralRegistry
func (t FromImageRegistry) AsGeneralRegistry() (GeneralRegistry, error) {
	var body GeneralRegistry
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromGeneralRegistry overwrites any union data inside the FromImageRegistry as the provided GeneralRegistry
func (t *FromImageRegistry) FromGeneralRegistry(v GeneralRegistry) error {
	v.Type = "registry"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeGeneralRegistry performs a merge with any union data inside the FromImageRegistry, using the provided GeneralRegistry
func (t *FromImageRegistry) MergeGeneralRegistry(v GeneralRegistry) error {
	v.Type = "registry"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t FromImageRegistry) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t FromImageRegistry) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "aws":
		return t.AsAWSRegistry()
	case "gcp":
		return t.AsGCPRegistry()
	case "registry":
		return t.AsGeneralRegistry()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t FromImageRegistry) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *FromImageRegistry) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// HealthCheck request
	HealthCheck(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListSandboxes request
	ListSandboxes(ctx context.Context, params *ListSandboxesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateSandboxWithBody request with any body
	CreateSandboxWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateSandbox(ctx context.Context, body CreateSandboxJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSandboxesMetrics request
	GetSandboxesMetrics(ctx context.Context, params *GetSandboxesMetricsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteSandbox request
	DeleteSandbox(ctx context.Context, sandboxID SandboxID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSandbox request
	GetSandbox(ctx context.Context, sandboxID SandboxID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ConnectSandboxWithBody request with any body
	ConnectSandboxWithBody(ctx context.Context, sandboxID SandboxID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ConnectSandbox(ctx context.Context, sandboxID SandboxID, body ConnectSandboxJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSandboxLogs request
	GetSandboxLogs(ctx context.Context, sandboxID SandboxID, params *GetSandboxLogsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSandboxMetrics request
	GetSandboxMetrics(ctx context.Context, sandboxID SandboxID, params *GetSandboxMetricsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PauseSandbox request
	PauseSandbox(ctx context.Context, sandboxID SandboxID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RefreshSandboxWithBody request with any body
	RefreshSandboxWithBody(ctx context.Context, sandboxID SandboxID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RefreshSandbox(ctx context.Context, sandboxID SandboxID, body RefreshSandboxJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ResumeSandboxWithBody request with any body
	ResumeSandboxWithBody(ctx context.Context, sandboxID SandboxID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ResumeSandbox(ctx context.Context, sandboxID SandboxID, body ResumeSandboxJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateSandboxTimeoutWithBody request with any body
	UpdateSandboxTimeoutWithBody(ctx context.Context, sandboxID SandboxID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateSandboxTimeout(ctx context.Context, sandboxID SandboxID, body UpdateSandboxTimeoutJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListTemplates request
	ListTemplates(ctx context.Context, params *ListTemplatesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateTemplateWithBody request with any body
	CreateTemplateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateTemplate(ctx context.Context, body CreateTemplateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTemplateByAlias request
	GetTemplateByAlias(ctx context.Context, alias string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteTemplateTagsWithBody request with any body
	DeleteTemplateTagsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DeleteTemplateTags(ctx context.Context, body DeleteTemplateTagsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ManageTemplateTagsWithBody request with any body
	ManageTemplateTagsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ManageTemplateTags(ctx context.Context, body ManageTemplateTagsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteTemplate request
	DeleteTemplate(ctx context.Context, templateID TemplateID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTemplate request
	GetTemplate(ctx context.Context, templateID TemplateID, params *GetTemplateParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateTemplateWithBody request with any body
	UpdateTemplateWithBody(ctx context.Context, templateID TemplateID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateTemplate(ctx context.Context, templateID TemplateID, body UpdateTemplateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RebuildTemplateWithBody request with any body
	RebuildTemplateWithBody(ctx context.Context, templateID TemplateID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RebuildTemplate(ctx context.Context, templateID TemplateID, body RebuildTemplateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StartTemplateBuild request
	StartTemplateBuild(ctx context.Context, templateID TemplateID, buildID BuildID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTemplateBuildLogs request
	GetTemplateBuildLogs(ctx context.Context, templateID TemplateID, buildID BuildID, params *GetTemplateBuildLogsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTemplateBuildStatus request
	GetTemplateBuildStatus(ctx context.Context, templateID TemplateID, buildID BuildID, params *GetTemplateBuildStatusParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTemplateFiles request
	GetTemplateFiles(ctx context.Context, templateID TemplateID, hash string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListSandboxesV2 request
	ListSandboxesV2(ctx context.Context, params *ListSandboxesV2Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateTemplateV2WithBody request with any body
	CreateTemplateV2WithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateTemplateV2(ctx context.Context, body CreateTemplateV2JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StartTemplateBuildV2WithBody request with any body
	StartTemplateBuildV2WithBody(ctx context.Context, templateID TemplateID, buildID BuildID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	StartTemplateBuildV2(ctx context.Context, templateID TemplateID, buildID BuildID, body StartTemplateBuildV2JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateTemplateV3WithBody request with any body
	CreateTemplateV3WithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateTemplateV3(ctx context.Context, body CreateTemplateV3JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) HealthCheck(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewHealthCheckRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListSandboxes(ctx context.Context, params *ListSandboxesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListSandboxesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSandboxWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSandboxRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSandbox(ctx context.Context, body CreateSandboxJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSandboxRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSandboxesMetrics(ctx context.Context, params *GetSandboxesMetricsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSandboxesMetricsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteSandbox(ctx context.Context, sandboxID SandboxID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteSandboxRequest(c.Server, sandboxID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSandbox(ctx context.Context, sandboxID SandboxID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSandboxRequest(c.Server, sandboxID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ConnectSandboxWithBody(ctx context.Context, sandboxID SandboxID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewConnectSandboxRequestWithBody(c.Server, sandboxID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ConnectSandbox(ctx context.Context, sandboxID SandboxID, body ConnectSandboxJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewConnectSandboxRequest(c.Server, sandboxID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSandboxLogs(ctx context.Context, sandboxID SandboxID, params *GetSandboxLogsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSandboxLogsRequest(c.Server, sandboxID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSandboxMetrics(ctx context.Context, sandboxID SandboxID, params *GetSandboxMetricsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSandboxMetricsRequest(c.Server, sandboxID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PauseSandbox(ctx context.Context, sandboxID SandboxID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPauseSandboxRequest(c.Server, sandboxID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RefreshSandboxWithBody(ctx context.Context, sandboxID SandboxID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRefreshSandboxRequestWithBody(c.Server, sandboxID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RefreshSandbox(ctx context.Context, sandboxID SandboxID, body RefreshSandboxJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRefreshSandboxRequest(c.Server, sandboxID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ResumeSandboxWithBody(ctx context.Context, sandboxID SandboxID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewResumeSandboxRequestWithBody(c.Server, sandboxID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ResumeSandbox(ctx context.Context, sandboxID SandboxID, body ResumeSandboxJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewResumeSandboxRequest(c.Server, sandboxID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateSandboxTimeoutWithBody(ctx context.Context, sandboxID SandboxID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateSandboxTimeoutRequestWithBody(c.Server, sandboxID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateSandboxTimeout(ctx context.Context, sandboxID SandboxID, body UpdateSandboxTimeoutJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateSandboxTimeoutRequest(c.Server, sandboxID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListTemplates(ctx context.Context, params *ListTemplatesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListTemplatesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateTemplateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateTemplateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateTemplate(ctx context.Context, body CreateTemplateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateTemplateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTemplateByAlias(ctx context.Context, alias string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTemplateByAliasRequest(c.Server, alias)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteTemplateTagsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteTemplateTagsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteTemplateTags(ctx context.Context, body DeleteTemplateTagsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteTemplateTagsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ManageTemplateTagsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewManageTemplateTagsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ManageTemplateTags(ctx context.Context, body ManageTemplateTagsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewManageTemplateTagsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteTemplate(ctx context.Context, templateID TemplateID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteTemplateRequest(c.Server, templateID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTemplate(ctx context.Context, templateID TemplateID, params *GetTemplateParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTemplateRequest(c.Server, templateID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateTemplateWithBody(ctx context.Context, templateID TemplateID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateTemplateRequestWithBody(c.Server, templateID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateTemplate(ctx context.Context, templateID TemplateID, body UpdateTemplateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateTemplateRequest(c.Server, templateID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RebuildTemplateWithBody(ctx context.Context, templateID TemplateID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRebuildTemplateRequestWithBody(c.Server, templateID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RebuildTemplate(ctx context.Context, templateID TemplateID, body RebuildTemplateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRebuildTemplateRequest(c.Server, templateID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StartTemplateBuild(ctx context.Context, templateID TemplateID, buildID BuildID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStartTemplateBuildRequest(c.Server, templateID, buildID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTemplateBuildLogs(ctx context.Context, templateID TemplateID, buildID BuildID, params *GetTemplateBuildLogsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTemplateBuildLogsRequest(c.Server, templateID, buildID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTemplateBuildStatus(ctx context.Context, templateID TemplateID, buildID BuildID, params *GetTemplateBuildStatusParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTemplateBuildStatusRequest(c.Server, templateID, buildID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTemplateFiles(ctx context.Context, templateID TemplateID, hash string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTemplateFilesRequest(c.Server, templateID, hash)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListSandboxesV2(ctx context.Context, params *ListSandboxesV2Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListSandboxesV2Request(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateTemplateV2WithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateTemplateV2RequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateTemplateV2(ctx context.Context, body CreateTemplateV2JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateTemplateV2Request(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StartTemplateBuildV2WithBody(ctx context.Context, templateID TemplateID, buildID BuildID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStartTemplateBuildV2RequestWithBody(c.Server, templateID, buildID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StartTemplateBuildV2(ctx context.Context, templateID TemplateID, buildID BuildID, body StartTemplateBuildV2JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStartTemplateBuildV2Request(c.Server, templateID, buildID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateTemplateV3WithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateTemplateV3RequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateTemplateV3(ctx context.Context, body CreateTemplateV3JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateTemplateV3Request(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewHealthCheckRequest generates requests for HealthCheck
func NewHealthCheckRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/health")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListSandboxesRequest generates requests for ListSandboxes
func NewListSandboxesRequest(server string, params *ListSandboxesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sandboxes")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Metadata != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "metadata", runtime.ParamLocationQuery, *params.Metadata); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateSandboxRequest calls the generic CreateSandbox builder with application/json body
func NewCreateSandboxRequest(server string, body CreateSandboxJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateSandboxRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateSandboxRequestWithBody generates requests for CreateSandbox with any type of body
func NewCreateSandboxRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sandboxes")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetSandboxesMetricsRequest generates requests for GetSandboxesMetrics
func NewGetSandboxesMetricsRequest(server string, params *GetSandboxesMetricsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sandboxes/metrics")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sandbox_ids", runtime.ParamLocationQuery, params.SandboxIds); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteSandboxRequest generates requests for DeleteSandbox
func NewDeleteSandboxRequest(server string, sandboxID SandboxID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "sandboxID", runtime.ParamLocationPath, sandboxID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sandboxes/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSandboxRequest generates requests for GetSandbox
func NewGetSandboxRequest(server string, sandboxID SandboxID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "sandboxID", runtime.ParamLocationPath, sandboxID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sandboxes/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewConnectSandboxRequest calls the generic ConnectSandbox builder with application/json body
func NewConnectSandboxRequest(server string, sandboxID SandboxID, body ConnectSandboxJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewConnectSandboxRequestWithBody(server, sandboxID, "application/json", bodyReader)
}

// NewConnectSandboxRequestWithBody generates requests for ConnectSandbox with any type of body
func NewConnectSandboxRequestWithBody(server string, sandboxID SandboxID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "sandboxID", runtime.ParamLocationPath, sandboxID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sandboxes/%s/connect", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetSandboxLogsRequest generates requests for GetSandboxLogs
func NewGetSandboxLogsRequest(server string, sandboxID SandboxID, params *GetSandboxLogsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "sandboxID", runtime.ParamLocationPath, sandboxID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sandboxes/%s/logs", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Start != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start", runtime.ParamLocationQuery, *params.Start); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSandboxMetricsRequest generates requests for GetSandboxMetrics
func NewGetSandboxMetricsRequest(server string, sandboxID SandboxID, params *GetSandboxMetricsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "sandboxID", runtime.ParamLocationPath, sandboxID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sandboxes/%s/metrics", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Start != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start", runtime.ParamLocationQuery, *params.Start); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.End != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end", runtime.ParamLocationQuery, *params.End); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPauseSandboxRequest generates requests for PauseSandbox
func NewPauseSandboxRequest(server string, sandboxID SandboxID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "sandboxID", runtime.ParamLocationPath, sandboxID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sandboxes/%s/pause", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRefreshSandboxRequest calls the generic RefreshSandbox builder with application/json body
func NewRefreshSandboxRequest(server string, sandboxID SandboxID, body RefreshSandboxJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRefreshSandboxRequestWithBody(server, sandboxID, "application/json", bodyReader)
}

// NewRefreshSandboxRequestWithBody generates requests for RefreshSandbox with any type of body
func NewRefreshSandboxRequestWithBody(server string, sandboxID SandboxID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "sandboxID", runtime.ParamLocationPath, sandboxID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sandboxes/%s/refreshes", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewResumeSandboxRequest calls the generic ResumeSandbox builder with application/json body
func NewResumeSandboxRequest(server string, sandboxID SandboxID, body ResumeSandboxJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewResumeSandboxRequestWithBody(server, sandboxID, "application/json", bodyReader)
}

// NewResumeSandboxRequestWithBody generates requests for ResumeSandbox with any type of body
func NewResumeSandboxRequestWithBody(server string, sandboxID SandboxID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "sandboxID", runtime.ParamLocationPath, sandboxID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sandboxes/%s/resume", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUpdateSandboxTimeoutRequest calls the generic UpdateSandboxTimeout builder with application/json body
func NewUpdateSandboxTimeoutRequest(server string, sandboxID SandboxID, body UpdateSandboxTimeoutJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateSandboxTimeoutRequestWithBody(server, sandboxID, "application/json", bodyReader)
}

// NewUpdateSandboxTimeoutRequestWithBody generates requests for UpdateSandboxTimeout with any type of body
func NewUpdateSandboxTimeoutRequestWithBody(server string, sandboxID SandboxID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "sandboxID", runtime.ParamLocationPath, sandboxID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sandboxes/%s/timeout", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListTemplatesRequest generates requests for ListTemplates
func NewListTemplatesRequest(server string, params *ListTemplatesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/templates")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TeamID != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "teamID", runtime.ParamLocationQuery, *params.TeamID); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateTemplateRequest calls the generic CreateTemplate builder with application/json body
func NewCreateTemplateRequest(server string, body CreateTemplateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateTemplateRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateTemplateRequestWithBody generates requests for CreateTemplate with any type of body
func NewCreateTemplateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/templates")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetTemplateByAliasRequest generates requests for GetTemplateByAlias
func NewGetTemplateByAliasRequest(server string, alias string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "alias", runtime.ParamLocationPath, alias)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/templates/aliases/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteTemplateTagsRequest calls the generic DeleteTemplateTags builder with application/json body
func NewDeleteTemplateTagsRequest(server string, body DeleteTemplateTagsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDeleteTemplateTagsRequestWithBody(server, "application/json", bodyReader)
}

// NewDeleteTemplateTagsRequestWithBody generates requests for DeleteTemplateTags with any type of body
func NewDeleteTemplateTagsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/templates/tags")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewManageTemplateTagsRequest calls the generic ManageTemplateTags builder with application/json body
func NewManageTemplateTagsRequest(server string, body ManageTemplateTagsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewManageTemplateTagsRequestWithBody(server, "application/json", bodyReader)
}

// NewManageTemplateTagsRequestWithBody generates requests for ManageTemplateTags with any type of body
func NewManageTemplateTagsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/templates/tags")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteTemplateRequest generates requests for DeleteTemplate
func NewDeleteTemplateRequest(server string, templateID TemplateID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "templateID", runtime.ParamLocationPath, templateID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/templates/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTemplateRequest generates requests for GetTemplate
func NewGetTemplateRequest(server string, templateID TemplateID, params *GetTemplateParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "templateID", runtime.ParamLocationPath, templateID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/templates/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.NextToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "nextToken", runtime.ParamLocationQuery, *params.NextToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateTemplateRequest calls the generic UpdateTemplate builder with application/json body
func NewUpdateTemplateRequest(server string, templateID TemplateID, body UpdateTemplateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateTemplateRequestWithBody(server, templateID, "application/json", bodyReader)
}

// NewUpdateTemplateRequestWithBody generates requests for UpdateTemplate with any type of body
func NewUpdateTemplateRequestWithBody(server string, templateID TemplateID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "templateID", runtime.ParamLocationPath, templateID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/templates/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRebuildTemplateRequest calls the generic RebuildTemplate builder with application/json body
func NewRebuildTemplateRequest(server string, templateID TemplateID, body RebuildTemplateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRebuildTemplateRequestWithBody(server, templateID, "application/json", bodyReader)
}

// NewRebuildTemplateRequestWithBody generates requests for RebuildTemplate with any type of body
func NewRebuildTemplateRequestWithBody(server string, templateID TemplateID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "templateID", runtime.ParamLocationPath, templateID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/templates/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewStartTemplateBuildRequest generates requests for StartTemplateBuild
func NewStartTemplateBuildRequest(server string, templateID TemplateID, buildID BuildID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "templateID", runtime.ParamLocationPath, templateID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "buildID", runtime.ParamLocationPath, buildID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/templates/%s/builds/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTemplateBuildLogsRequest generates requests for GetTemplateBuildLogs
func NewGetTemplateBuildLogsRequest(server string, templateID TemplateID, buildID BuildID, params *GetTemplateBuildLogsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "templateID", runtime.ParamLocationPath, templateID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "buildID", runtime.ParamLocationPath, buildID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/templates/%s/builds/%s/logs", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Direction != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "direction", runtime.ParamLocationQuery, *params.Direction); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Level != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "level", runtime.ParamLocationQuery, *params.Level); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Source != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "source", runtime.ParamLocationQuery, *params.Source); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTemplateBuildStatusRequest generates requests for GetTemplateBuildStatus
func NewGetTemplateBuildStatusRequest(server string, templateID TemplateID, buildID BuildID, params *GetTemplateBuildStatusParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "templateID", runtime.ParamLocationPath, templateID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "buildID", runtime.ParamLocationPath, buildID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/templates/%s/builds/%s/status", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.LogsOffset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "logsOffset", runtime.ParamLocationQuery, *params.LogsOffset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Level != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "level", runtime.ParamLocationQuery, *params.Level); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTemplateFilesRequest generates requests for GetTemplateFiles
func NewGetTemplateFilesRequest(server string, templateID TemplateID, hash string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "templateID", runtime.ParamLocationPath, templateID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "hash", runtime.ParamLocationPath, hash)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/templates/%s/files/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListSandboxesV2Request generates requests for ListSandboxesV2
func NewListSandboxesV2Request(server string, params *ListSandboxesV2Params) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/sandboxes")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Metadata != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "metadata", runtime.ParamLocationQuery, *params.Metadata); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.State != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "state", runtime.ParamLocationQuery, *params.State); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NextToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "nextToken", runtime.ParamLocationQuery, *params.NextToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateTemplateV2Request calls the generic CreateTemplateV2 builder with application/json body
func NewCreateTemplateV2Request(server string, body CreateTemplateV2JSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateTemplateV2RequestWithBody(server, "application/json", bodyReader)
}

// NewCreateTemplateV2RequestWithBody generates requests for CreateTemplateV2 with any type of body
func NewCreateTemplateV2RequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/templates")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewStartTemplateBuildV2Request calls the generic StartTemplateBuildV2 builder with application/json body
func NewStartTemplateBuildV2Request(server string, templateID TemplateID, buildID BuildID, body StartTemplateBuildV2JSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewStartTemplateBuildV2RequestWithBody(server, templateID, buildID, "application/json", bodyReader)
}

// NewStartTemplateBuildV2RequestWithBody generates requests for StartTemplateBuildV2 with any type of body
func NewStartTemplateBuildV2RequestWithBody(server string, templateID TemplateID, buildID BuildID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "templateID", runtime.ParamLocationPath, templateID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "buildID", runtime.ParamLocationPath, buildID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/templates/%s/builds/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateTemplateV3Request calls the generic CreateTemplateV3 builder with application/json body
func NewCreateTemplateV3Request(server string, body CreateTemplateV3JSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateTemplateV3RequestWithBody(server, "application/json", bodyReader)
}

// NewCreateTemplateV3RequestWithBody generates requests for CreateTemplateV3 with any type of body
func NewCreateTemplateV3RequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v3/templates")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// HealthCheckWithResponse request
	HealthCheckWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*HealthCheckResponse, error)

	// ListSandboxesWithResponse request
	ListSandboxesWithResponse(ctx context.Context, params *ListSandboxesParams, reqEditors ...RequestEditorFn) (*ListSandboxesResponse, error)

	// CreateSandboxWithBodyWithResponse request with any body
	CreateSandboxWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSandboxResponse, error)

	CreateSandboxWithResponse(ctx context.Context, body CreateSandboxJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSandboxResponse, error)

	// GetSandboxesMetricsWithResponse request
	GetSandboxesMetricsWithResponse(ctx context.Context, params *GetSandboxesMetricsParams, reqEditors ...RequestEditorFn) (*GetSandboxesMetricsResponse, error)

	// DeleteSandboxWithResponse request
	DeleteSandboxWithResponse(ctx context.Context, sandboxID SandboxID, reqEditors ...RequestEditorFn) (*DeleteSandboxResponse, error)

	// GetSandboxWithResponse request
	GetSandboxWithResponse(ctx context.Context, sandboxID SandboxID, reqEditors ...RequestEditorFn) (*GetSandboxResponse, error)

	// ConnectSandboxWithBodyWithResponse request with any body
	ConnectSandboxWithBodyWithResponse(ctx context.Context, sandboxID SandboxID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ConnectSandboxResponse, error)

	ConnectSandboxWithResponse(ctx context.Context, sandboxID SandboxID, body ConnectSandboxJSONRequestBody, reqEditors ...RequestEditorFn) (*ConnectSandboxResponse, error)

	// GetSandboxLogsWithResponse request
	GetSandboxLogsWithResponse(ctx context.Context, sandboxID SandboxID, params *GetSandboxLogsParams, reqEditors ...RequestEditorFn) (*GetSandboxLogsResponse, error)

	// GetSandboxMetricsWithResponse request
	GetSandboxMetricsWithResponse(ctx context.Context, sandboxID SandboxID, params *GetSandboxMetricsParams, reqEditors ...RequestEditorFn) (*GetSandboxMetricsResponse, error)

	// PauseSandboxWithResponse request
	PauseSandboxWithResponse(ctx context.Context, sandboxID SandboxID, reqEditors ...RequestEditorFn) (*PauseSandboxResponse, error)

	// RefreshSandboxWithBodyWithResponse request with any body
	RefreshSandboxWithBodyWithResponse(ctx context.Context, sandboxID SandboxID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RefreshSandboxResponse, error)

	RefreshSandboxWithResponse(ctx context.Context, sandboxID SandboxID, body RefreshSandboxJSONRequestBody, reqEditors ...RequestEditorFn) (*RefreshSandboxResponse, error)

	// ResumeSandboxWithBodyWithResponse request with any body
	ResumeSandboxWithBodyWithResponse(ctx context.Context, sandboxID SandboxID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ResumeSandboxResponse, error)

	ResumeSandboxWithResponse(ctx context.Context, sandboxID SandboxID, body ResumeSandboxJSONRequestBody, reqEditors ...RequestEditorFn) (*ResumeSandboxResponse, error)

	// UpdateSandboxTimeoutWithBodyWithResponse request with any body
	UpdateSandboxTimeoutWithBodyWithResponse(ctx context.Context, sandboxID SandboxID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateSandboxTimeoutResponse, error)

	UpdateSandboxTimeoutWithResponse(ctx context.Context, sandboxID SandboxID, body UpdateSandboxTimeoutJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateSandboxTimeoutResponse, error)

	// ListTemplatesWithResponse request
	ListTemplatesWithResponse(ctx context.Context, params *ListTemplatesParams, reqEditors ...RequestEditorFn) (*ListTemplatesResponse, error)

	// CreateTemplateWithBodyWithResponse request with any body
	CreateTemplateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateTemplateResponse, error)

	CreateTemplateWithResponse(ctx context.Context, body CreateTemplateJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateTemplateResponse, error)

	// GetTemplateByAliasWithResponse request
	GetTemplateByAliasWithResponse(ctx context.Context, alias string, reqEditors ...RequestEditorFn) (*GetTemplateByAliasResponse, error)

	// DeleteTemplateTagsWithBodyWithResponse request with any body
	DeleteTemplateTagsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteTemplateTagsResponse, error)

	DeleteTemplateTagsWithResponse(ctx context.Context, body DeleteTemplateTagsJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteTemplateTagsResponse, error)

	// ManageTemplateTagsWithBodyWithResponse request with any body
	ManageTemplateTagsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ManageTemplateTagsResponse, error)

	ManageTemplateTagsWithResponse(ctx context.Context, body ManageTemplateTagsJSONRequestBody, reqEditors ...RequestEditorFn) (*ManageTemplateTagsResponse, error)

	// DeleteTemplateWithResponse request
	DeleteTemplateWithResponse(ctx context.Context, templateID TemplateID, reqEditors ...RequestEditorFn) (*DeleteTemplateResponse, error)

	// GetTemplateWithResponse request
	GetTemplateWithResponse(ctx context.Context, templateID TemplateID, params *GetTemplateParams, reqEditors ...RequestEditorFn) (*GetTemplateResponse, error)

	// UpdateTemplateWithBodyWithResponse request with any body
	UpdateTemplateWithBodyWithResponse(ctx context.Context, templateID TemplateID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateTemplateResponse, error)

	UpdateTemplateWithResponse(ctx context.Context, templateID TemplateID, body UpdateTemplateJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateTemplateResponse, error)

	// RebuildTemplateWithBodyWithResponse request with any body
	RebuildTemplateWithBodyWithResponse(ctx context.Context, templateID TemplateID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RebuildTemplateResponse, error)

	RebuildTemplateWithResponse(ctx context.Context, templateID TemplateID, body RebuildTemplateJSONRequestBody, reqEditors ...RequestEditorFn) (*RebuildTemplateResponse, error)

	// StartTemplateBuildWithResponse request
	StartTemplateBuildWithResponse(ctx context.Context, templateID TemplateID, buildID BuildID, reqEditors ...RequestEditorFn) (*StartTemplateBuildResponse, error)

	// GetTemplateBuildLogsWithResponse request
	GetTemplateBuildLogsWithResponse(ctx context.Context, templateID TemplateID, buildID BuildID, params *GetTemplateBuildLogsParams, reqEditors ...RequestEditorFn) (*GetTemplateBuildLogsResponse, error)

	// GetTemplateBuildStatusWithResponse request
	GetTemplateBuildStatusWithResponse(ctx context.Context, templateID TemplateID, buildID BuildID, params *GetTemplateBuildStatusParams, reqEditors ...RequestEditorFn) (*GetTemplateBuildStatusResponse, error)

	// GetTemplateFilesWithResponse request
	GetTemplateFilesWithResponse(ctx context.Context, templateID TemplateID, hash string, reqEditors ...RequestEditorFn) (*GetTemplateFilesResponse, error)

	// ListSandboxesV2WithResponse request
	ListSandboxesV2WithResponse(ctx context.Context, params *ListSandboxesV2Params, reqEditors ...RequestEditorFn) (*ListSandboxesV2Response, error)

	// CreateTemplateV2WithBodyWithResponse request with any body
	CreateTemplateV2WithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateTemplateV2Response, error)

	CreateTemplateV2WithResponse(ctx context.Context, body CreateTemplateV2JSONRequestBody, reqEditors ...RequestEditorFn) (*CreateTemplateV2Response, error)

	// StartTemplateBuildV2WithBodyWithResponse request with any body
	StartTemplateBuildV2WithBodyWithResponse(ctx context.Context, templateID TemplateID, buildID BuildID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*StartTemplateBuildV2Response, error)

	StartTemplateBuildV2WithResponse(ctx context.Context, templateID TemplateID, buildID BuildID, body StartTemplateBuildV2JSONRequestBody, reqEditors ...RequestEditorFn) (*StartTemplateBuildV2Response, error)

	// CreateTemplateV3WithBodyWithResponse request with any body
	CreateTemplateV3WithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateTemplateV3Response, error)

	CreateTemplateV3WithResponse(ctx context.Context, body CreateTemplateV3JSONRequestBody, reqEditors ...RequestEditorFn) (*CreateTemplateV3Response, error)
}

type HealthCheckResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *N401
}

// Status returns HTTPResponse.Status
func (r HealthCheckResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r HealthCheckResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListSandboxesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]ListedSandbox
	JSON400      *N400
	JSON401      *N401
	JSON500      *N500
}

// Status returns HTTPResponse.Status
func (r ListSandboxesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListSandboxesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateSandboxResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Sandbox
	JSON400      *N400
	JSON401      *N401
	JSON500      *N500
}

// Status returns HTTPResponse.Status
func (r CreateSandboxResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateSandboxResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSandboxesMetricsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SandboxesWithMetrics
	JSON400      *N400
	JSON401      *N401
	JSON500      *N500
}

// Status returns HTTPResponse.Status
func (r GetSandboxesMetricsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSandboxesMetricsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteSandboxResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *N401
	JSON404      *N404
	JSON500      *N500
}

// Status returns HTTPResponse.Status
func (r DeleteSandboxResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteSandboxResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSandboxResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SandboxDetail
	JSON401      *N401
	JSON404      *N404
	JSON500      *N500
}

// Status returns HTTPResponse.Status
func (r GetSandboxResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSandboxResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ConnectSandboxResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Sandbox
	JSON201      *Sandbox
	JSON400      *N400
	JSON401      *N401
	JSON404      *N404
	JSON500      *N500
}

// Status returns HTTPResponse.Status
func (r ConnectSandboxResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ConnectSandboxResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSandboxLogsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SandboxLogs
	JSON401      *N401
	JSON404      *N404
	JSON500      *N500
}

// Status returns HTTPResponse.Status
func (r GetSandboxLogsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSandboxLogsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSandboxMetricsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]SandboxMetric
	JSON400      *N400
	JSON401      *N401
	JSON404      *N404
	JSON500      *N500
}

// Status returns HTTPResponse.Status
func (r GetSandboxMetricsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSandboxMetricsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PauseSandboxResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *N401
	JSON404      *N404
	JSON409      *N409
	JSON500      *N500
}

// Status returns HTTPResponse.Status
func (r PauseSandboxResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PauseSandboxResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RefreshSandboxResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *N401
	JSON404      *N404
}

// Status returns HTTPResponse.Status
func (r RefreshSandboxResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RefreshSandboxResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ResumeSandboxResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Sandbox
	JSON401      *N401
	JSON404      *N404
	JSON409      *N409
	JSON500      *N500
}

// Status returns HTTPResponse.Status
func (r ResumeSandboxResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ResumeSandboxResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateSandboxTimeoutResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *N401
	JSON404      *N404
	JSON500      *N500
}

// Status returns HTTPResponse.Status
func (r UpdateSandboxTimeoutResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateSandboxTimeoutResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListTemplatesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Template
	JSON401      *N401
	JSON500      *N500
}

// Status returns HTTPResponse.Status
func (r ListTemplatesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListTemplatesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateTemplateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *TemplateLegacy
	JSON400      *N400
	JSON401      *N401
	JSON500      *N500
}

// Status returns HTTPResponse.Status
func (r CreateTemplateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateTemplateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTemplateByAliasResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TemplateAliasResponse
	JSON400      *N400
	JSON403      *N403
	JSON404      *N404
	JSON500      *N500
}

// Status returns HTTPResponse.Status
func (r GetTemplateByAliasResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTemplateByAliasResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteTemplateTagsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *N400
	JSON401      *N401
	JSON404      *N404
	JSON500      *N500
}

// Status returns HTTPResponse.Status
func (r DeleteTemplateTagsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteTemplateTagsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ManageTemplateTagsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *AssignedTemplateTags
	JSON400      *N400
	JSON401      *N401
	JSON404      *N404
	JSON500      *N500
}

// Status returns HTTPResponse.Status
func (r ManageTemplateTagsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ManageTemplateTagsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteTemplateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *N401
	JSON500      *N500
}

// Status returns HTTPResponse.Status
func (r DeleteTemplateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteTemplateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTemplateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TemplateWithBuilds
	JSON401      *N401
	JSON500      *N500
}

// Status returns HTTPResponse.Status
func (r GetTemplateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTemplateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateTemplateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *N400
	JSON401      *N401
	JSON500      *N500
}

// Status returns HTTPResponse.Status
func (r UpdateTemplateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateTemplateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RebuildTemplateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *TemplateLegacy
	JSON401      *N401
	JSON500      *N500
}

// Status returns HTTPResponse.Status
func (r RebuildTemplateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RebuildTemplateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StartTemplateBuildResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *N401
	JSON500      *N500
}

// Status returns HTTPResponse.Status
func (r StartTemplateBuildResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StartTemplateBuildResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTemplateBuildLogsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TemplateBuildLogsResponse
	JSON401      *N401
	JSON404      *N404
	JSON500      *N500
}

// Status returns HTTPResponse.Status
func (r GetTemplateBuildLogsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTemplateBuildLogsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTemplateBuildStatusResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TemplateBuildInfo
	JSON401      *N401
	JSON404      *N404
	JSON500      *N500
}

// Status returns HTTPResponse.Status
func (r GetTemplateBuildStatusResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTemplateBuildStatusResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTemplateFilesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *TemplateBuildFileUpload
	JSON400      *N400
	JSON401      *N401
	JSON404      *N404
	JSON500      *N500
}

// Status returns HTTPResponse.Status
func (r GetTemplateFilesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTemplateFilesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListSandboxesV2Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]ListedSandbox
	JSON400      *N400
	JSON401      *N401
	JSON500      *N500
}

// Status returns HTTPResponse.Status
func (r ListSandboxesV2Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListSandboxesV2Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateTemplateV2Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *TemplateLegacy
	JSON400      *N400
	JSON401      *N401
	JSON500      *N500
}

// Status returns HTTPResponse.Status
func (r CreateTemplateV2Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateTemplateV2Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StartTemplateBuildV2Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *N401
	JSON500      *N500
}

// Status returns HTTPResponse.Status
func (r StartTemplateBuildV2Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StartTemplateBuildV2Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateTemplateV3Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *TemplateRequestResponseV3
	JSON400      *N400
	JSON401      *N401
	JSON500      *N500
}

// Status returns HTTPResponse.Status
func (r CreateTemplateV3Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateTemplateV3Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// HealthCheckWithResponse request returning *HealthCheckResponse
func (c *ClientWithResponses) HealthCheckWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*HealthCheckResponse, error) {
	rsp, err := c.HealthCheck(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseHealthCheckResponse(rsp)
}

// ListSandboxesWithResponse request returning *ListSandboxesResponse
func (c *ClientWithResponses) ListSandboxesWithResponse(ctx context.Context, params *ListSandboxesParams, reqEditors ...RequestEditorFn) (*ListSandboxesResponse, error) {
	rsp, err := c.ListSandboxes(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListSandboxesResponse(rsp)
}

// CreateSandboxWithBodyWithResponse request with arbitrary body returning *CreateSandboxResponse
func (c *ClientWithResponses) CreateSandboxWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSandboxResponse, error) {
	rsp, err := c.CreateSandboxWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSandboxResponse(rsp)
}

func (c *ClientWithResponses) CreateSandboxWithResponse(ctx context.Context, body CreateSandboxJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSandboxResponse, error) {
	rsp, err := c.CreateSandbox(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSandboxResponse(rsp)
}

// GetSandboxesMetricsWithResponse request returning *GetSandboxesMetricsResponse
func (c *ClientWithResponses) GetSandboxesMetricsWithResponse(ctx context.Context, params *GetSandboxesMetricsParams, reqEditors ...RequestEditorFn) (*GetSandboxesMetricsResponse, error) {
	rsp, err := c.GetSandboxesMetrics(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSandboxesMetricsResponse(rsp)
}

// DeleteSandboxWithResponse request returning *DeleteSandboxResponse
func (c *ClientWithResponses) DeleteSandboxWithResponse(ctx context.Context, sandboxID SandboxID, reqEditors ...RequestEditorFn) (*DeleteSandboxResponse, error) {
	rsp, err := c.DeleteSandbox(ctx, sandboxID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteSandboxResponse(rsp)
}

// GetSandboxWithResponse request returning *GetSandboxResponse
func (c *ClientWithResponses) GetSandboxWithResponse(ctx context.Context, sandboxID SandboxID, reqEditors ...RequestEditorFn) (*GetSandboxResponse, error) {
	rsp, err := c.GetSandbox(ctx, sandboxID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSandboxResponse(rsp)
}

// ConnectSandboxWithBodyWithResponse request with arbitrary body returning *ConnectSandboxResponse
func (c *ClientWithResponses) ConnectSandboxWithBodyWithResponse(ctx context.Context, sandboxID SandboxID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ConnectSandboxResponse, error) {
	rsp, err := c.ConnectSandboxWithBody(ctx, sandboxID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseConnectSandboxResponse(rsp)
}

func (c *ClientWithResponses) ConnectSandboxWithResponse(ctx context.Context, sandboxID SandboxID, body ConnectSandboxJSONRequestBody, reqEditors ...RequestEditorFn) (*ConnectSandboxResponse, error) {
	rsp, err := c.ConnectSandbox(ctx, sandboxID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseConnectSandboxResponse(rsp)
}

// GetSandboxLogsWithResponse request returning *GetSandboxLogsResponse
func (c *ClientWithResponses) GetSandboxLogsWithResponse(ctx context.Context, sandboxID SandboxID, params *GetSandboxLogsParams, reqEditors ...RequestEditorFn) (*GetSandboxLogsResponse, error) {
	rsp, err := c.GetSandboxLogs(ctx, sandboxID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSandboxLogsResponse(rsp)
}

// GetSandboxMetricsWithResponse request returning *GetSandboxMetricsResponse
func (c *ClientWithResponses) GetSandboxMetricsWithResponse(ctx context.Context, sandboxID SandboxID, params *GetSandboxMetricsParams, reqEditors ...RequestEditorFn) (*GetSandboxMetricsResponse, error) {
	rsp, err := c.GetSandboxMetrics(ctx, sandboxID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSandboxMetricsResponse(rsp)
}

// PauseSandboxWithResponse request returning *PauseSandboxResponse
func (c *ClientWithResponses) PauseSandboxWithResponse(ctx context.Context, sandboxID SandboxID, reqEditors ...RequestEditorFn) (*PauseSandboxResponse, error) {
	rsp, err := c.PauseSandbox(ctx, sandboxID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePauseSandboxResponse(rsp)
}

// RefreshSandboxWithBodyWithResponse request with arbitrary body returning *RefreshSandboxResponse
func (c *ClientWithResponses) RefreshSandboxWithBodyWithResponse(ctx context.Context, sandboxID SandboxID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RefreshSandboxResponse, error) {
	rsp, err := c.RefreshSandboxWithBody(ctx, sandboxID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRefreshSandboxResponse(rsp)
}

func (c *ClientWithResponses) RefreshSandboxWithResponse(ctx context.Context, sandboxID SandboxID, body RefreshSandboxJSONRequestBody, reqEditors ...RequestEditorFn) (*RefreshSandboxResponse, error) {
	rsp, err := c.RefreshSandbox(ctx, sandboxID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRefreshSandboxResponse(rsp)
}

// ResumeSandboxWithBodyWithResponse request with arbitrary body returning *ResumeSandboxResponse
func (c *ClientWithResponses) ResumeSandboxWithBodyWithResponse(ctx context.Context, sandboxID SandboxID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ResumeSandboxResponse, error) {
	rsp, err := c.ResumeSandboxWithBody(ctx, sandboxID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseResumeSandboxResponse(rsp)
}

func (c *ClientWithResponses) ResumeSandboxWithResponse(ctx context.Context, sandboxID SandboxID, body ResumeSandboxJSONRequestBody, reqEditors ...RequestEditorFn) (*ResumeSandboxResponse, error) {
	rsp, err := c.ResumeSandbox(ctx, sandboxID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseResumeSandboxResponse(rsp)
}

// UpdateSandboxTimeoutWithBodyWithResponse request with arbitrary body returning *UpdateSandboxTimeoutResponse
func (c *ClientWithResponses) UpdateSandboxTimeoutWithBodyWithResponse(ctx context.Context, sandboxID SandboxID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateSandboxTimeoutResponse, error) {
	rsp, err := c.UpdateSandboxTimeoutWithBody(ctx, sandboxID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateSandboxTimeoutResponse(rsp)
}

func (c *ClientWithResponses) UpdateSandboxTimeoutWithResponse(ctx context.Context, sandboxID SandboxID, body UpdateSandboxTimeoutJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateSandboxTimeoutResponse, error) {
	rsp, err := c.UpdateSandboxTimeout(ctx, sandboxID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateSandboxTimeoutResponse(rsp)
}

// ListTemplatesWithResponse request returning *ListTemplatesResponse
func (c *ClientWithResponses) ListTemplatesWithResponse(ctx context.Context, params *ListTemplatesParams, reqEditors ...RequestEditorFn) (*ListTemplatesResponse, error) {
	rsp, err := c.ListTemplates(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListTemplatesResponse(rsp)
}

// CreateTemplateWithBodyWithResponse request with arbitrary body returning *CreateTemplateResponse
func (c *ClientWithResponses) CreateTemplateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateTemplateResponse, error) {
	rsp, err := c.CreateTemplateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateTemplateResponse(rsp)
}

func (c *ClientWithResponses) CreateTemplateWithResponse(ctx context.Context, body CreateTemplateJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateTemplateResponse, error) {
	rsp, err := c.CreateTemplate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateTemplateResponse(rsp)
}

// GetTemplateByAliasWithResponse request returning *GetTemplateByAliasResponse
func (c *ClientWithResponses) GetTemplateByAliasWithResponse(ctx context.Context, alias string, reqEditors ...RequestEditorFn) (*GetTemplateByAliasResponse, error) {
	rsp, err := c.GetTemplateByAlias(ctx, alias, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTemplateByAliasResponse(rsp)
}

// DeleteTemplateTagsWithBodyWithResponse request with arbitrary body returning *DeleteTemplateTagsResponse
func (c *ClientWithResponses) DeleteTemplateTagsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteTemplateTagsResponse, error) {
	rsp, err := c.DeleteTemplateTagsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteTemplateTagsResponse(rsp)
}

func (c *ClientWithResponses) DeleteTemplateTagsWithResponse(ctx context.Context, body DeleteTemplateTagsJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteTemplateTagsResponse, error) {
	rsp, err := c.DeleteTemplateTags(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteTemplateTagsResponse(rsp)
}

// ManageTemplateTagsWithBodyWithResponse request with arbitrary body returning *ManageTemplateTagsResponse
func (c *ClientWithResponses) ManageTemplateTagsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ManageTemplateTagsResponse, error) {
	rsp, err := c.ManageTemplateTagsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseManageTemplateTagsResponse(rsp)
}

func (c *ClientWithResponses) ManageTemplateTagsWithResponse(ctx context.Context, body ManageTemplateTagsJSONRequestBody, reqEditors ...RequestEditorFn) (*ManageTemplateTagsResponse, error) {
	rsp, err := c.ManageTemplateTags(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseManageTemplateTagsResponse(rsp)
}

// DeleteTemplateWithResponse request returning *DeleteTemplateResponse
func (c *ClientWithResponses) DeleteTemplateWithResponse(ctx context.Context, templateID TemplateID, reqEditors ...RequestEditorFn) (*DeleteTemplateResponse, error) {
	rsp, err := c.DeleteTemplate(ctx, templateID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteTemplateResponse(rsp)
}

// GetTemplateWithResponse request returning *GetTemplateResponse
func (c *ClientWithResponses) GetTemplateWithResponse(ctx context.Context, templateID TemplateID, params *GetTemplateParams, reqEditors ...RequestEditorFn) (*GetTemplateResponse, error) {
	rsp, err := c.GetTemplate(ctx, templateID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTemplateResponse(rsp)
}

// UpdateTemplateWithBodyWithResponse request with arbitrary body returning *UpdateTemplateResponse
func (c *ClientWithResponses) UpdateTemplateWithBodyWithResponse(ctx context.Context, templateID TemplateID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateTemplateResponse, error) {
	rsp, err := c.UpdateTemplateWithBody(ctx, templateID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateTemplateResponse(rsp)
}

func (c *ClientWithResponses) UpdateTemplateWithResponse(ctx context.Context, templateID TemplateID, body UpdateTemplateJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateTemplateResponse, error) {
	rsp, err := c.UpdateTemplate(ctx, templateID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateTemplateResponse(rsp)
}

// RebuildTemplateWithBodyWithResponse request with arbitrary body returning *RebuildTemplateResponse
func (c *ClientWithResponses) RebuildTemplateWithBodyWithResponse(ctx context.Context, templateID TemplateID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RebuildTemplateResponse, error) {
	rsp, err := c.RebuildTemplateWithBody(ctx, templateID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRebuildTemplateResponse(rsp)
}

func (c *ClientWithResponses) RebuildTemplateWithResponse(ctx context.Context, templateID TemplateID, body RebuildTemplateJSONRequestBody, reqEditors ...RequestEditorFn) (*RebuildTemplateResponse, error) {
	rsp, err := c.RebuildTemplate(ctx, templateID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRebuildTemplateResponse(rsp)
}

// StartTemplateBuildWithResponse request returning *StartTemplateBuildResponse
func (c *ClientWithResponses) StartTemplateBuildWithResponse(ctx context.Context, templateID TemplateID, buildID BuildID, reqEditors ...RequestEditorFn) (*StartTemplateBuildResponse, error) {
	rsp, err := c.StartTemplateBuild(ctx, templateID, buildID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStartTemplateBuildResponse(rsp)
}

// GetTemplateBuildLogsWithResponse request returning *GetTemplateBuildLogsResponse
func (c *ClientWithResponses) GetTemplateBuildLogsWithResponse(ctx context.Context, templateID TemplateID, buildID BuildID, params *GetTemplateBuildLogsParams, reqEditors ...RequestEditorFn) (*GetTemplateBuildLogsResponse, error) {
	rsp, err := c.GetTemplateBuildLogs(ctx, templateID, buildID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTemplateBuildLogsResponse(rsp)
}

// GetTemplateBuildStatusWithResponse request returning *GetTemplateBuildStatusResponse
func (c *ClientWithResponses) GetTemplateBuildStatusWithResponse(ctx context.Context, templateID TemplateID, buildID BuildID, params *GetTemplateBuildStatusParams, reqEditors ...RequestEditorFn) (*GetTemplateBuildStatusResponse, error) {
	rsp, err := c.GetTemplateBuildStatus(ctx, templateID, buildID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTemplateBuildStatusResponse(rsp)
}

// GetTemplateFilesWithResponse request returning *GetTemplateFilesResponse
func (c *ClientWithResponses) GetTemplateFilesWithResponse(ctx context.Context, templateID TemplateID, hash string, reqEditors ...RequestEditorFn) (*GetTemplateFilesResponse, error) {
	rsp, err := c.GetTemplateFiles(ctx, templateID, hash, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTemplateFilesResponse(rsp)
}

// ListSandboxesV2WithResponse request returning *ListSandboxesV2Response
func (c *ClientWithResponses) ListSandboxesV2WithResponse(ctx context.Context, params *ListSandboxesV2Params, reqEditors ...RequestEditorFn) (*ListSandboxesV2Response, error) {
	rsp, err := c.ListSandboxesV2(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListSandboxesV2Response(rsp)
}

// CreateTemplateV2WithBodyWithResponse request with arbitrary body returning *CreateTemplateV2Response
func (c *ClientWithResponses) CreateTemplateV2WithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateTemplateV2Response, error) {
	rsp, err := c.CreateTemplateV2WithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateTemplateV2Response(rsp)
}

func (c *ClientWithResponses) CreateTemplateV2WithResponse(ctx context.Context, body CreateTemplateV2JSONRequestBody, reqEditors ...RequestEditorFn) (*CreateTemplateV2Response, error) {
	rsp, err := c.CreateTemplateV2(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateTemplateV2Response(rsp)
}

// StartTemplateBuildV2WithBodyWithResponse request with arbitrary body returning *StartTemplateBuildV2Response
func (c *ClientWithResponses) StartTemplateBuildV2WithBodyWithResponse(ctx context.Context, templateID TemplateID, buildID BuildID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*StartTemplateBuildV2Response, error) {
	rsp, err := c.StartTemplateBuildV2WithBody(ctx, templateID, buildID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStartTemplateBuildV2Response(rsp)
}

func (c *ClientWithResponses) StartTemplateBuildV2WithResponse(ctx context.Context, templateID TemplateID, buildID BuildID, body StartTemplateBuildV2JSONRequestBody, reqEditors ...RequestEditorFn) (*StartTemplateBuildV2Response, error) {
	rsp, err := c.StartTemplateBuildV2(ctx, templateID, buildID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStartTemplateBuildV2Response(rsp)
}

// CreateTemplateV3WithBodyWithResponse request with arbitrary body returning *CreateTemplateV3Response
func (c *ClientWithResponses) CreateTemplateV3WithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateTemplateV3Response, error) {
	rsp, err := c.CreateTemplateV3WithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateTemplateV3Response(rsp)
}

func (c *ClientWithResponses) CreateTemplateV3WithResponse(ctx context.Context, body CreateTemplateV3JSONRequestBody, reqEditors ...RequestEditorFn) (*CreateTemplateV3Response, error) {
	rsp, err := c.CreateTemplateV3(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateTemplateV3Response(rsp)
}

// ParseHealthCheckResponse parses an HTTP response from a HealthCheckWithResponse call
func ParseHealthCheckResponse(rsp *http.Response) (*HealthCheckResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &HealthCheckResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseListSandboxesResponse parses an HTTP response from a ListSandboxesWithResponse call
func ParseListSandboxesResponse(rsp *http.Response) (*ListSandboxesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListSandboxesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []ListedSandbox
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCreateSandboxResponse parses an HTTP response from a CreateSandboxWithResponse call
func ParseCreateSandboxResponse(rsp *http.Response) (*CreateSandboxResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateSandboxResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Sandbox
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetSandboxesMetricsResponse parses an HTTP response from a GetSandboxesMetricsWithResponse call
func ParseGetSandboxesMetricsResponse(rsp *http.Response) (*GetSandboxesMetricsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSandboxesMetricsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SandboxesWithMetrics
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteSandboxResponse parses an HTTP response from a DeleteSandboxWithResponse call
func ParseDeleteSandboxResponse(rsp *http.Response) (*DeleteSandboxResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteSandboxResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest N404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetSandboxResponse parses an HTTP response from a GetSandboxWithResponse call
func ParseGetSandboxResponse(rsp *http.Response) (*GetSandboxResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSandboxResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SandboxDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest N404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseConnectSandboxResponse parses an HTTP response from a ConnectSandboxWithResponse call
func ParseConnectSandboxResponse(rsp *http.Response) (*ConnectSandboxResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ConnectSandboxResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Sandbox
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Sandbox
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest N404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetSandboxLogsResponse parses an HTTP response from a GetSandboxLogsWithResponse call
func ParseGetSandboxLogsResponse(rsp *http.Response) (*GetSandboxLogsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSandboxLogsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SandboxLogs
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest N404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetSandboxMetricsResponse parses an HTTP response from a GetSandboxMetricsWithResponse call
func ParseGetSandboxMetricsResponse(rsp *http.Response) (*GetSandboxMetricsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSandboxMetricsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []SandboxMetric
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest N404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePauseSandboxResponse parses an HTTP response from a PauseSandboxWithResponse call
func ParsePauseSandboxResponse(rsp *http.Response) (*PauseSandboxResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PauseSandboxResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest N404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest N409
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseRefreshSandboxResponse parses an HTTP response from a RefreshSandboxWithResponse call
func ParseRefreshSandboxResponse(rsp *http.Response) (*RefreshSandboxResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RefreshSandboxResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest N404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseResumeSandboxResponse parses an HTTP response from a ResumeSandboxWithResponse call
func ParseResumeSandboxResponse(rsp *http.Response) (*ResumeSandboxResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ResumeSandboxResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Sandbox
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest N404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest N409
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdateSandboxTimeoutResponse parses an HTTP response from a UpdateSandboxTimeoutWithResponse call
func ParseUpdateSandboxTimeoutResponse(rsp *http.Response) (*UpdateSandboxTimeoutResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateSandboxTimeoutResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest N404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListTemplatesResponse parses an HTTP response from a ListTemplatesWithResponse call
func ParseListTemplatesResponse(rsp *http.Response) (*ListTemplatesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListTemplatesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Template
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCreateTemplateResponse parses an HTTP response from a CreateTemplateWithResponse call
func ParseCreateTemplateResponse(rsp *http.Response) (*CreateTemplateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateTemplateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest TemplateLegacy
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetTemplateByAliasResponse parses an HTTP response from a GetTemplateByAliasWithResponse call
func ParseGetTemplateByAliasResponse(rsp *http.Response) (*GetTemplateByAliasResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTemplateByAliasResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TemplateAliasResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest N403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest N404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteTemplateTagsResponse parses an HTTP response from a DeleteTemplateTagsWithResponse call
func ParseDeleteTemplateTagsResponse(rsp *http.Response) (*DeleteTemplateTagsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteTemplateTagsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest N404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseManageTemplateTagsResponse parses an HTTP response from a ManageTemplateTagsWithResponse call
func ParseManageTemplateTagsResponse(rsp *http.Response) (*ManageTemplateTagsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ManageTemplateTagsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest AssignedTemplateTags
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest N404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteTemplateResponse parses an HTTP response from a DeleteTemplateWithResponse call
func ParseDeleteTemplateResponse(rsp *http.Response) (*DeleteTemplateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteTemplateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetTemplateResponse parses an HTTP response from a GetTemplateWithResponse call
func ParseGetTemplateResponse(rsp *http.Response) (*GetTemplateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTemplateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TemplateWithBuilds
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdateTemplateResponse parses an HTTP response from a UpdateTemplateWithResponse call
func ParseUpdateTemplateResponse(rsp *http.Response) (*UpdateTemplateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateTemplateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseRebuildTemplateResponse parses an HTTP response from a RebuildTemplateWithResponse call
func ParseRebuildTemplateResponse(rsp *http.Response) (*RebuildTemplateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RebuildTemplateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest TemplateLegacy
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseStartTemplateBuildResponse parses an HTTP response from a StartTemplateBuildWithResponse call
func ParseStartTemplateBuildResponse(rsp *http.Response) (*StartTemplateBuildResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StartTemplateBuildResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetTemplateBuildLogsResponse parses an HTTP response from a GetTemplateBuildLogsWithResponse call
func ParseGetTemplateBuildLogsResponse(rsp *http.Response) (*GetTemplateBuildLogsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTemplateBuildLogsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TemplateBuildLogsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest N404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetTemplateBuildStatusResponse parses an HTTP response from a GetTemplateBuildStatusWithResponse call
func ParseGetTemplateBuildStatusResponse(rsp *http.Response) (*GetTemplateBuildStatusResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTemplateBuildStatusResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TemplateBuildInfo
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest N404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetTemplateFilesResponse parses an HTTP response from a GetTemplateFilesWithResponse call
func ParseGetTemplateFilesResponse(rsp *http.Response) (*GetTemplateFilesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTemplateFilesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest TemplateBuildFileUpload
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest N404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListSandboxesV2Response parses an HTTP response from a ListSandboxesV2WithResponse call
func ParseListSandboxesV2Response(rsp *http.Response) (*ListSandboxesV2Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListSandboxesV2Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []ListedSandbox
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCreateTemplateV2Response parses an HTTP response from a CreateTemplateV2WithResponse call
func ParseCreateTemplateV2Response(rsp *http.Response) (*CreateTemplateV2Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateTemplateV2Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest TemplateLegacy
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseStartTemplateBuildV2Response parses an HTTP response from a StartTemplateBuildV2WithResponse call
func ParseStartTemplateBuildV2Response(rsp *http.Response) (*StartTemplateBuildV2Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StartTemplateBuildV2Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCreateTemplateV3Response parses an HTTP response from a CreateTemplateV3WithResponse call
func ParseCreateTemplateV3Response(rsp *http.Response) (*CreateTemplateV3Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateTemplateV3Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest TemplateRequestResponseV3
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}
